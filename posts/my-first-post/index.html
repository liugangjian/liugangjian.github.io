<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>My 10st post | Gangjian Liu</title>
<meta name=keywords content="first">
<meta name=description content="Desc Text.">
<meta name=author content="Gangjian Liu">
<link rel=canonical href=https://canonical.url/to/page>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://adityatelange.in/assets/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://liugangjian.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=https://liugangjian.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=https://liugangjian.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=https://liugangjian.github.io/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script src=https://code.jquery.com/jquery-3.1.1.min.js></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="My 10st post">
<meta property="og:description" content="Desc Text.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://liugangjian.github.io/posts/my-first-post/">
<meta property="og:image" content="https://liugangjian.github.io/posts/my-first-post/https:/raw.githubusercontent.com/liugangjian/blogImag/master/Complexity/20200404172539.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2020-09-15T11:30:03+00:00">
<meta property="article:modified_time" content="2020-09-15T11:30:03+00:00"><meta property="og:site_name" content="Gangjian Liu">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://liugangjian.github.io/posts/my-first-post/https:/raw.githubusercontent.com/liugangjian/blogImag/master/Complexity/20200404172539.png">
<meta name=twitter:title content="My 10st post">
<meta name=twitter:description content="Desc Text.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://liugangjian.github.io/posts/"},{"@type":"ListItem","position":2,"name":"My 10st post","item":"https://liugangjian.github.io/posts/my-first-post/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"My 10st post","name":"My 10st post","description":"Desc Text.","keywords":["first"],"articleBody":"The following HTML — elements represent six levels of section headings.  is the highest section level while  is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don’t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren’t part of the core Markdown spec, but Hugo supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Italics Bold Code     italics bold code    Code Blocks Code block with backticks  html lang=\"en\" head meta charset=\"utf-8\" / titleExample HTML5 Documenttitle head body pTestp body html Code block indented with four spaces  Example HTML5 Document   Test\n   Code block with Hugo’s internal highlight shortcode  html lang=\"en\" head meta charset=\"utf-8\" titleExample HTML5 Documenttitle head body pTestp body html Gist  List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Fruit  Apple Orange Banana   Dairy  Milk Cheese    Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures. Drafts do not get deployed; once you finish a post, update the header of the post to say draft: false. More info here. $$ \\begin{pmatrix} a \u0026 b \\\\ c \u0026 d \\end{pmatrix} $$\nType of Complexity Spatial Complexity The spatial complexity $$\\mathring{g}$$ {%math%}S(n){%endmath%} is the length of the storage unit that is occupied by the program written according to the algorithm.\nThis length is often related to the size of the input data. An algorithm with too much space complexity may cause memory overruns to be used, causing abnormal program interruption.\nTime Complexity The time complexity {%math%}T(n){%endmath%} is the length of time that the program written according to the algorithm takes time to execute.\nThis length is also often related to the size of the input data. Inefficient algorithms with excessive time complexity may cause us to wait for the results of our operations for the rest of our lives.\nWhat is a Good Algorithm? When analyzing the efficiency of general algorithms, we often pay attention to the following two kinds of complexity:\n  Worst case complexity {%math%}T_{worst}(n){%endmath%};\n  Average complexity {%math%}T_{avg}(n){%endmath%}.\n  {%math%}\nT_{avg}(n) \\le T_{worst}(n)\n{%endmath%}\nWhy focus on the worst case?   The worst case gives the upper bound on the execution time of the algorithm. We can be sure that the execution time of the algorithm will not exceed this upper bound no matter what input is given, which facilitates comparison and analysis.\n  For some algorithms, the worst case is the most common case, such as the algorithm for finding a certain information in the database. The worst case is that the information does not exist in the database at all, and it is not found. And some applications often have to find a message that does not exist in the database.\n  Although the worst case is a pessimistic estimate, for many problems, the average case and the worst case time complexity are similar, such as insertion ordering, averaging and worst case time complexity are quadratic functions of input length {%math%}n{%endmath%}.\n  Progressive Representation of Complexity   Progressive Representation  Asymptotic mark Symbol {%math%}\\Theta{%endmath%} The {%math%}\\Theta{%endmath%} mark progressively gives the upper and lower bounds of a function. If there are normal quantities {%math%}c_1{%endmath%} and {%math%}c_2{%endmath%}, so that for a sufficiently large {%math%}n{%endmath%}, the function {%math%}f(n){%endmath%} can be sandwiched between {%math%}c_1g(n){%endmath%} and {%math%}c_2g(n){%endmath%}, that is, {%math%}f(n){%endmath%} and {%math%}\\Theta(g(n)){%endmath%} are The same magnitude. We usually write “{%math%}f(n)=\\Theta(g(n)){%endmath%}” to express the same concept.\nSymbol {%math%}O{%endmath%} {%math%}O{%endmath%} read as large {%math%}O(g(n)){%endmath%}, sometimes only read as {%math%}O(g(n)){%endmath%} gives a progressive upper bound on a function.\nSymbol {%math%}\\Omega{%endmath%} The {%math%}\\Omega{%endmath%} token gives the progressive lower bound of a function.\nSymbol {%math%}o{%endmath%} and {%math%}\\omega{%endmath%} There are also {%math%}o{%endmath%} marks and {%math%}\\omega{%endmath%} marks, which represent a non-progressively accurate upper bound and a non-progressively tight lower bound.\nMemory tips  The meaning of {%math%}\\Theta{%endmath%} is similar to “equal to”; The meaning of {%math%}O{%endmath%} is similar to “less than or equal to”; The meaning of {%math%}\\Omega{%endmath%} is similar to “greater than or equal to”; The meaning of {%math%}o{%endmath%} is similar to “less than”; The meaning of {%math%}\\omega{%endmath%} is similar to “greater than”;  Several common time complexity          Deep understanding  Introduction to MIT Algorithm: Asymptotic Symbol, Recursion and Solution   垃圾回收     如何判断对象可回收 引用计数法 在Java中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个对象如果没有任何与之关联的引用，即他们的引用计数都不为0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。\n但是可能存在循环引用的问题，两个对象之间相互引用，再没有其他对象引用他们，但这两个对象都会因计数不为零而无法进行回收，造成内存泄漏。\n    可达性分析法 为了解决引用计数法的循环引用问题，Java使用了可达性分析的方法。通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。\n要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。\n  可以用eclipse提供的工具进行查看  Java中五种引用     强引用 上图中A1对象为强引用。\n它在Java中最常见的就是强引用，**把一个对象赋给一个引用变量，这个引用变量就是一个强引用。**当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成Java内存泄漏的主要原因之一。\n 只有所有 GC Roots 对象都不通过强引用引用该对象，该对象才能被垃圾回收  软引用 上图A2对象为软引用。\n软引用需要用SoftReference类来实现，对于只有软引用的对象来说，**当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。**软引用通常用在对内存敏感的程序中。\n由于软引用自身也是一个对象，也需要占用一部分的内存，如果软引用在创建时，给他分配了一个引用队列，那么在软引用所引用的对象被垃圾回收时，软引用对象会进入引用队列，等待队列的遍历释放这部分的内存。\n 仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象 可以配合引用队列来释放软引用自身  弱引用 上图A3对象为弱引用。\n弱引用需要用WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，总会回收该对象占用的内存。\n弱引用对象的释放和软引用相同：\n由于弱引用自身也是一个对象，也需要占用一部分的内存，如果弱引用在创建时，给他分配了一个引用队列，那么在弱引用所引用的对象被垃圾回收时，弱引用对象会进入引用队列，等待队列的遍历释放这部分的内存。\n 仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象 可以配合引用队列来释放弱引用自身  虚引用     虚引用需要PhantomReference类来实现，它不能单独使用，也必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。\n比如在内存结构中的直接内存章节，在创建ByteBuffer实现类对象时，会自动创建一个名为Cleaner的虚引用对象指向直接内存的地址。当将来没有强引用指向ByteBuffer时，ByteBuffer对象会被回收，但是分配的直接内存并不能被Java回收。\n在ByteBuffer被回收的时候，虚引用对象进入引用队列，而虚引用所在的引用队列，会有一个线程检查看有没有一个新入队的Cleaner，如果有则会调用虚引用中的clean方法，用Unsafe.freeMemory将直接内存释放掉，这样避免了直接内存的内存泄露问题，之后将虚引用对象回收掉。\n 必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存  终结器     上图A4对象为终结器引用。\n所有的Java对象都继承自Object父类，而Object类中都有finallize()方法（终结方法），如果对象重写了终结方法并且没有强引用引用它时，虚拟机会创建该对象的终结器引用，当对象发生垃圾回收时，该对象的终结器引用会加入引用队列中，再由一个优先级很低的线程查看在队列中是否存在终结器引用，根据终结器引用找到待回收的对象并调用它的finallize()方法。之后将终结器引用对象回收掉。\n不过我们发现finallize()方法的工作效率很低，他在第一次回收时，并不能立即释放掉而是先入队，而且处理队列的线程的优先级很低，这就导致了对象的finallize()方法迟迟得不到调用，该对象所占用的资源迟迟得不到释放，所以并不推荐使用finallize()方法去释放资源。\n 无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize方法，第二次 GC 时才能回收被引用对象  垃圾回收算法 标记清除算法(Mark Sweep) 最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。如图所示。\n    从图中我们就可以发现，该算法最大的问题是内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题。\n标记整理算法(Mark Compact) 标记阶段和标记清除算法Mark-Sweep算法相同，标记后不是清理对象，而是将存活对象移向内存的一端，然后清除端边界外的对象。**优点是内存碎片化的问题得以解决，缺点是由于在清理的过程中存在对象的移动，需要改变这些对象的引用地址，使得效率较低，速度慢。**如图：\n    复制算法(copying) 为了解决Mark-Sweep算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉，如图：\n    这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，Copying算法的效率会大大降低。\n 不会有内存碎片 需要双倍的内存空间  JVM 运行时内存 Java堆从GC的角度还可以细分为: 新生代(Eden区、From Survivor区和To Survivor区)和老年代。\n    新生代 是用来存放新生的对象。一般占据堆的1/3空间。由于频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收。新生代又分为 Eden区、ServivorFrom、ServivorTo三个区。\nEden Java新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行一次垃圾回收。\nServivorFrom 上一次GC的幸存者，作为这一次GC的被扫描者。\nServivorTo 保留了一次MinorGC过程中的幸存者。\nMinorGC的过程（复制-清空-互换） MinorGC采用复制算法。\n eden、servicorFrom 复制到ServicorTo，年龄+1 首先，把Eden和ServivorFrom区域中存活的对象复制到ServicorTo区域（如果有对象的年龄以及达到了老年的标准，则复制到老年代区），同时把这些对象的年龄+1（如果ServicorTo不够位置了就放到老年区）； 清空eden、servicorFrom 然后，清空Eden和ServicorFrom中的对象； ServicorTo和ServicorFrom互换 最后，ServicorTo和ServicorFrom互换，原ServicorTo成为下一次GC时的ServicorFrom区。  老年代 主要存放应用程序中生命周期长的内存对象。\n老年代的对象比较稳定，所以Full/Major GC不会频繁执行。**在进行MajorGC前一般都先进行了一次MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。**当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间。MajorGC的速度会比MinorGC慢十倍以上。\nMajorGC采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC的耗时比较长，因为要扫描再回收。MajorGC会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常。\n触发机制：\n 当年轻代满时就会触发Minor GC,这里的年轻代是指Eden区满，Survivor区满不会引发. 当老年代满的时候，会触发Full GC，同时回收年轻代，年老代，当永久代满了以后也会触发Full GC.  永久代 指内存的永久保存区域，主要存放Class和Meta（元数据）的信息,Class在被加载的时候被放入永久区域，它和存放实例的区域不同,GC不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常。\n    在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。\n类的元数据放入 native memory, 字符串池和类的静态变量放入java堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制。\n分代收集算法 分代收集法是目前大部分JVM所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将GC堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)。\n老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。\n新生代与复制算法 目前大部分JVM的GC对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照1：1来划分新生代。\n一般将新生代划分为一块较大的Eden空间和两个较小的Survivor空间(From Space, To Space)，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将该两块空间中还存活的对象复制到另一块Survivor空间中。\n    老年代与标记整理算法 老年代因为每次只回收少量对象，因而采用Mark-Compact算法。\n JAVA虚拟机提到过的处于方法区的永生代(PermanetGeneration)，它用来存储class类，常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。 对象的内存分配主要在新生代的Eden Space和Survivor Space的FromSpace(Survivor目前存放对象的那一块)，少数情况会直接分配到老生代。 当新生代的Eden Space和From Space空间不足时就会发生一次GC，进行GC后，Eden Space和From Space区的存活对象会被挪到To Space，然后将Eden Space和From Space进行清理。 如果To Space无法足够存储某个对象，则将这个对象存储到老生代。 在进行GC后，使用的便是Eden Space和To Space了，如此反复循环。 当对象在Survivor区躲过一次GC后，其年龄就会+1。默认情况下年龄到达15的对象会被移到老生代中。  通俗的说：\n 对象首先分配在伊甸园区域 新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1并且交换 from to minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行 当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit） 当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时间更长  分代收集算法 VS 分区收集算法 分代收集算法 当前主流VM垃圾收集都采用”分代收集”(Generational Collection)算法, 这种算法会根据对象存活周期的不同将内存划分为几块, 如JVM中的 新生代、老年代、永久代，这样就可以根据各年代特点分别采用最适当的GC算法。\n新生代——复制算法 每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集.\n老年代——标记整理算法 因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存.\n分区收集算法 分区算法则将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收. 这样做的好处是可以控制一次回收多少个小区间 , 根据目标停顿时间, 每次合理地回收若干个小区间(而不是整个堆), 从而减少一次GC所产生的停顿。\n分代回收相关参数    名词 指令     堆初始大小 -Xms   堆最大大小 -Xmx 或 -XX:MaxHeapSize=size   新生代大小 -Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )   幸存区比例（动态） -XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy   幸存区比例 -XX:SurvivorRatio=ratio   晋升阈值 -XX:MaxTenuringThreshold=threshold   晋升详情 -XX:+PrintTenuringDistribution   GC详情 -XX:+PrintGCDetails -verbose:gc   Full GC 前 Minor GC -XX:+ScavengeBeforeFullGC    垃圾收集器 Java堆内存被划分为新生代和年老代两部分\n 新生代主要使用复制和标记-清除垃圾回收算法； 年老代主要使用标记-整理垃圾回收算法。  因此java虚拟中针对新生代和年老代分别提供了多种不同的垃圾收集器，JDK1.6中Sun HotSpot虚拟机的垃圾收集器如下：\n      串行\n 单线程 堆内存较小，适合个人电脑    串行    吞吐量优先\n 让单位时间内，STW 的时间最短 0.2 0.2 = 0.4，垃圾回收时间占比最低，这样就称吞吐量高    吞吐量优先    响应时间优先\n 多线程 堆内存较大，多核 cpu 尽可能让单次 STW 的时间最短 0.1 0.1 0.1 0.1 0.1 = 0.5    响应时间优先    Serial垃圾收集器 串行、单线程、复制算法\n-XX:+UseSerialGC = Serial + SerialOld\nSerial（英文连续）是最基本垃圾收集器，使用复制算法，曾经是JDK1.3.1之前新生代唯一的垃圾收集器。Serial是一个单线程的收集器，它不但只会使用一个CPU或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。\nSerial垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个CPU环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此Serial垃圾收集器依然是java虚拟机运行在Client模式下默认的新生代垃圾收集器。\nSerial Old收集器 串行、单线程、标记整理算法\nSerial Old是Serial垃圾收集器年老代版本，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在Client默认的java虚拟机默认的年老代垃圾收集器。 在Server模式下，主要有两个用途：\n 在JDK1.5之前版本中与新生代的Parallel Scavenge收集器搭配使用。 作为年老代中使用CMS收集器的后备垃圾收集方案。  新生代Serial与年老代Serial Old搭配垃圾收集过程图：\n    新生代Parallel Scavenge收集器与ParNew收集器工作原理类似，都是多线程的收集器，都使用的是复制算法，在垃圾收集过程中都需要暂停所有的工作线程。新生代Parallel Scavenge/ParNew与年老代Serial Old搭配垃圾收集过程图：\n    ParNew垃圾收集器 吞吐量优先、复制算法、Serial+多线程\nParNew垃圾收集器其实是Serial收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和Serial收集器完全一样，ParNew垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。\nParNew收集器默认开启和CPU数目相同的线程数，可以通过-XX:ParallelGCThreads参数来限制垃圾收集器的线程数。Parallel：平行的 ParNew虽然是除了多线程外和Serial收集器几乎完全一样，但是ParNew垃圾收集器是很多java虚拟机运行在Server模式下新生代的默认垃圾收集器。\nParallel Scavenge收集器 吞吐量优先、多线程、复制算法、高效\nParallel Scavenge收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集器，它重点关注的是程序达到一个可控制的吞吐量（Thoughput，CPU用于运行用户代码的时间/CPU总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)），高吞吐量可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。自适应调节策略也是ParallelScavenge收集器与ParNew收集器的一个重要区别。\nParallel Old收集器 吞吐量优先、多线程、标记整理算法\nParallel Old收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在JDK1.6才开始提供。\n在JDK1.6之前，新生代使用ParallelScavenge收集器只能搭配年老代的Serial Old收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old正是为了在年老代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，可以优先考虑新生代Parallel Scavenge和年老代Parallel Old收集器的搭配策略。\n新生代Parallel Scavenge和年老代Parallel Old收集器搭配运行过程图：\n    不难发现，以上几种垃圾收集器中：\n 新生代采用的都是复制算法 老年代采用的都是标记整理算法  CMS收集器 响应时间优先、多线程、标记清除算法\nConcurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。 最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。 CMS工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下4个阶段：\n初始标记 速度快 只是标记一下GC Roots能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。\n并发标记 速度慢 进行GC Roots跟踪的过程，和用户线程一起工作，不需要暂停工作线程。\n重新标记 速度快 为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。\n并发清除 速度慢 清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。\n由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS收集器的内存回收和用户线程是一起并发地执行。\nCMS垃圾回收器存在的最大的问题是：由于采用的是标记清除算法，在回收的过程中可能会产生内存碎片，并且是并发收集，其他线程在执行的过程中会产生浮动垃圾，可能导致并发失败，此时会退化为Seriaold垃圾回收器，采用单线程串行的垃圾回收，如果发生并发失败，则垃圾回收的时间会飙升，不符合响应时间优先的初衷\nCMS收集器工作过程：\n    G1垃圾回收器 Garbage first垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与CMS收集器，G1收集器两个最突出的改进是：\n 基于标记-整理算法，不产生内存碎片。 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。  G1收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保G1收集器可以在有限时间获得最高的垃圾收集效率。\n定义：Garbage First\n 2004 论文发布 2009 JDK 6u14 体验 2012 JDK 7u4 官方支持 2017 JDK 9 默认  适用场景\n 同时注重吞吐量（Throughput）和低延迟（Low latency），默认的暂停目标是 200 ms 超大堆内存，会将堆划分为多个大小相等的 Region 整体上是标记+整理算法，两个区域之间是复制算法  随着堆内存的增大，G1回收器较CMS的优势逐渐明显。\n相关 JVM 参数\n-XX:+UseG1GC -XX:G1HeapRegionSize=size -XX:MaxGCPauseMillis=time G1垃圾回收阶段   循环执行  Young Collection  会STW    初始状态，创建对象放在新生代    发生垃圾回收时，幸存者放入S区    发生垃圾回收时，满足年龄者放入老年代  Young Collection + CM 新生代的垃圾回收和并发标记阶段\n 在 Young GC 时会进行 GC Root 的初始标记 当老年代占用堆空间比例达到阈值时，进行并发标记（不会 STW），由下面的 JVM 参数决定  -XX:InitiatingHeapOccupancyPercent=percent(默认45%)   当老年代占堆内存空间的45%时，触发并发标记  混合收集  会对 E、S、O 进行全面垃圾回收 最终标记（Remark）会 STW 拷贝存活（Evacuation）会 STW  -XX:MaxGCPauseMillis=ms   挑选回收区域最高的进行回收来达到最大暂停时间  Garbage first的含义也是优先收集那些回收价值区域比较大的区块。\nYoung Collection 跨代引用 新生代回收的跨代引用（老年代引用新生代）问题\n 卡表与 Remembered Set 在引用变更时通过 post-write barrier + dirty card queue concurrent refinement threads 更新 Remembered Set  新生代在进行回收时，首先要找到跟对象，然后再进行可达性分析，找到存活对象再进行复制到幸存区等操作。\n而跟对象有一部分是来自老年代的，老年代存活的对象是非常多的，因此遍历的效率很低，于是我们采用的是一种卡表的技术，把老年代的区域再进行细分，每一个card占512K，如果老年代其中有一个对象引用了新生代的对象，那我们把该card标记为脏卡。\n这样做的好处是我们不用对整个老年代遍历，而只用关心脏卡区域就可以了，这样可以减少搜索范围，提高效率。\n    JDK 8u20 字符串去重  优点：节省大量内存 缺点：略微多占用了 cpu 时间，新生代回收时间略微增加 -XX:+UseStringDeduplication  String s1 = new String(\"hello\"); // char[]{'h','e','l','l','o'} String s2 = new String(\"hello\"); // char[]{'h','e','l','l','o'}  将所有新分配的字符串放入一个队列 当新生代回收时，G1并发检查是否有字符串重复 如果它们值一样，让它们引用同一个 char[] 注意，与 String.intern() 不一样  String.intern() 关注的是字符串对象 而字符串去重关注的是 char[] 在 JVM 内部，使用了不同的字符串表    JDK 8u40 并发标记类卸载 所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类 -XX:+ClassUnloadingWithConcurrentMark 默认启用\nJDK 8u60 回收巨型对象      一个对象大于 region 的一半时，称之为巨型对象 G1 不会对巨型对象进行拷贝 回收时被优先考虑 G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生 代垃圾回收时处理掉  JDK 9 并发标记起始时间的调整 并发标记必须在堆空间占满前完成，否则退化为 FullGC\n JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent JDK 9 可以动态调整  XX:InitiatingHeapOccupancyPercent 用来设置初始值 进行数据采样并动态调整 总会添加一个安全的空档空间    可以让并发标记，混合收集提前开始来防止发生并发垃圾回收退化为Full GC的垃圾回收\nJDK 9 更高效的回收  250+增强 180+bug修复 HotSpot Virtual Machine Garbage Collection Tuning Guide G1越来越好了！  Remark 辨析  重标记辨析,写屏障技术视频详解\n 重标记 pre-write barrier + satb_mark_queue remark阶段配合satb_mark_queue队列来进行判断。  下图中：\n 黑色代表已处理完的对象 褐色代表正在处理的对象 箭头代表有强引用的对象 白色代表可回收的垃圾      由于是并发标记，所以在发现一个对象没有被强引用后，该对象被标记为可回收，但是标记的过程是和线程并发的，所以在这过程中可能有别的线程改变了该对象的引用。\n    如果再回收此对象，则会发生重大的错误，于是在并发标记后会使用重新标记来解决此类问题。\n     在对象的引用发生改变时，JVM会给它加入一个写屏障，写屏障的指令将C加入一个队列当中，并将其变为灰色，表示还没处理完，当并发标记结束后，重新标记的线程就会从队列中把对象取出来再进行进一步的处理。\n结果发现C有强引用，则将其变为黑色，则不会将C对象当成垃圾回收掉。\nFull GC 辨析 SerialGC  新生代内存不足发生的垃圾收集 - minor gc 老年代内存不足发生的垃圾收集 - full gc  ParallelGC  新生代内存不足发生的垃圾收集 - minor gc 老年代内存不足发生的垃圾收集 - full gc  CMS  新生代内存不足发生的垃圾收集 - minor gc 老年代内存不足  G1  新生代内存不足发生的垃圾收集 - minor gc 老年代内存不足  CMS和G1由于是并发标记和收集的阶段，如果回收的速度大于垃圾产生的速度，这时候还谈不上发生Full GC. 只有当垃圾的产生速度大于回速度的时候，会退化为串行的垃圾收集器，触发Full GC，导致STW，使得响应时间变长。\n可以通过打印GC日志观察是否又FUll GC字样来判断是否发生了Full GC.\n垃圾回收器相关参数 串行 -XX:+UseSerialGC = Serial + SerialOld 吞吐量优先 -XX:+UseParallelGC ~ -XX:+UseParallelOldGC -XX:GCTimeRatio=ratio -XX:MaxGCPauseMillis=ms -XX:ParallelGCThreads=n 响应时间优先 -XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld -XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads -XX:CMSInitiatingOccupancyFraction=percent -XX:+CMSScavengeBeforeRemark GC 调优  掌握 GC 相关的 VM 参数，会基本的空间调整 掌握相关工具 明白一点：调优跟应用、环境有关，没有放之四海而皆准的法则  调优领域  内存(GC) 锁竞争 cpu 占用 io  调优目标  【低延迟】还是【高吞吐量】？【网站开发】还是【科学研究】？选择合适的回收器 CMS，G1，ZGC ParallelGC Zing 零挺对，几乎没有STW时间  最快的 GC 是不发生 GC  查看 FullGC 前后的内存占用，考虑下面几个问题  数据是不是太多？  resultSet = statement.executeQuery(“select * from 大表 limit n”)   数据表示是否太臃肿？  对象图 对象大小 16 Integer 24 int 4   是否存在内存泄漏？  static Map map = 软 弱 第三方缓存实现      新生代调优  新生代的特点  所有的 new 操作的内存分配非常廉价  TLAB thread-local allocation buffer     死亡对象的回收代价是零 大部分对象用过即死 Minor GC 的时间远远低于 Full GC 新生代越大越好吗？  -Xmn Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery). GC is performed in this region more often than in other regions. If the size for the young generation is too small, then a lot of minor garbage collections are performed. If the size is too large, then only full garbage collections are performed, which can take a long time to complete. Oracle recommends that you keep the size for the young generation greater than 25% and less than 50% of the overall heap size.   新生代能容纳所有【并发量 * (请求-响应)】的数据 幸存区大到能保留【当前活跃对象+需要晋升对象】 晋升阈值配置得当，让长时间存活对象尽快晋升  -XX:MaxTenuringThreshold=threshold -XX:+PrintTenuringDistribution Desired survivor size 48286924 bytes, new threshold 10 (max 10) - age 1: 28992024 bytes, 28992024 total - age 2: 1366864 bytes, 30358888 total - age 3: 1425912 bytes, 31784800 total ... 老年代调优 以 CMS 为例\n CMS 的老年代内存越大越好 先尝试不做调优，如果没有 Full GC 那么已经…，否则先尝试调优新生代 观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1/4 ~ 1/3  -XX:CMSInitiatingOccupancyFraction=percent//发生老年代垃圾回收的阈值 案例  案例1 Full GC 和 Minor GC频繁  可能是由于新生代的内存太小，导致在新对象创建时，Survivor区空间不够而需要下调晋升代数，导致很多对象提前放入老年代中从而恶性循环，因此可以尝试调大新生代的空间。   案例2 请求高峰期发生 Full GC，单次暂停时间特别长 （CMS）  查看GC日志，看看是在哪个阶段耗时长，由于初始标记和并发标记比较快，重新标记时间比较长，重新标记需要扫描整个新生代，老年代，因此可以在重新标记之前，对新生代发生一次垃圾回收。  -XX:+CMSScavengeBeforeRemark  案例3 老年代充裕情况下，发生 Full GC （CMS jdk1.7）  1.7是由于永久代的空间不足发生Full GC 在1.8以后可能可能是由于元空间的不足引发的Full GC.      The above quote is excerpted from Rob Pike’s talk during Gopherfest, November 18, 2015. ↩︎\n   ","wordCount":"1790","inLanguage":"en","image":"https://liugangjian.github.io/posts/my-first-post/https:/raw.githubusercontent.com/liugangjian/blogImag/master/Complexity/20200404172539.png","datePublished":"2020-09-15T11:30:03Z","dateModified":"2020-09-15T11:30:03Z","author":{"@type":"Person","name":"Gangjian Liu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://liugangjian.github.io/posts/my-first-post/"},"publisher":{"@type":"Organization","name":"Gangjian Liu","logo":{"@type":"ImageObject","url":"https://adityatelange.in/assets/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://liugangjian.github.io/ accesskey=h title="‹ Home › (Alt + H)">‹ Home ›</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://liugangjian.github.io/archives/ title=archive>
<span>archive</span>
</a>
</li>
<li>
<a href=https://liugangjian.github.io/categories/ title=categories>
<span>categories</span>
</a>
</li>
<li>
<a href=https://liugangjian.github.io/tags/ title=tags>
<span>tags</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://liugangjian.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://liugangjian.github.io/posts/>Posts</a></div>
<h1 class=post-title>
My 10st post<sup><span class=entry-isdraft>&nbsp;&nbsp;[draft]</span></sup>
</h1>
<div class=post-description>
Desc Text.
</div>
<div class=post-meta><span title="2020-09-15 11:30:03 +0000 +0000">September 15, 2020</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Gangjian Liu&nbsp;|&nbsp;<a href=https://github.com/liuagnjian/liugangjian.github.io/content/posts/my-first-post.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#h1 aria-label=H1>H1</a><ul>
<li>
<a href=#h2 aria-label=H2>H2</a><ul>
<li>
<a href=#h3 aria-label=H3>H3</a><ul>
<li>
<a href=#h4 aria-label=H4>H4</a><ul>
<li>
<a href=#h5 aria-label=H5>H5</a><ul>
<li>
<a href=#h6 aria-label=H6>H6</a></li></ul>
</li></ul>
</li></ul>
</li></ul>
</li>
<li>
<a href=#paragraph aria-label=Paragraph>Paragraph</a></li>
<li>
<a href=#blockquotes aria-label=Blockquotes>Blockquotes</a><ul>
<ul>
<li>
<a href=#blockquote-without-attribution aria-label="Blockquote without attribution">Blockquote without attribution</a></li>
<li>
<a href=#blockquote-with-attribution aria-label="Blockquote with attribution">Blockquote with attribution</a></li></ul>
</ul>
</li>
<li>
<a href=#tables aria-label=Tables>Tables</a><ul>
<ul>
<li>
<a href=#inline-markdown-within-tables aria-label="Inline Markdown within tables">Inline Markdown within tables</a></li></ul>
</ul>
</li>
<li>
<a href=#code-blocks aria-label="Code Blocks">Code Blocks</a><ul>
<ul>
<li>
<a href=#code-block-with-backticks aria-label="Code block with backticks">Code block with backticks</a></li>
<li>
<a href=#code-block-indented-with-four-spaces aria-label="Code block indented with four spaces">Code block indented with four spaces</a></li>
<li>
<a href=#code-block-with-hugos-internal-highlight-shortcode aria-label="Code block with Hugo&amp;rsquo;s internal highlight shortcode">Code block with Hugo&rsquo;s internal highlight shortcode</a></li>
<li>
<a href=#gist aria-label=Gist>Gist</a></li></ul>
</ul>
</li>
<li>
<a href=#list-types aria-label="List Types">List Types</a><ul>
<ul>
<li>
<a href=#ordered-list aria-label="Ordered List">Ordered List</a></li>
<li>
<a href=#unordered-list aria-label="Unordered List">Unordered List</a></li>
<li>
<a href=#nested-list aria-label="Nested list">Nested list</a></li></ul>
</ul>
</li>
<li>
<a href=#other-elements--abbr-sub-sup-kbd-mark aria-label="Other Elements — abbr, sub, sup, kbd, mark">Other Elements — abbr, sub, sup, kbd, mark</a></li>
<li>
<a href=#type-of-complexity aria-label="Type of Complexity">Type of Complexity</a><ul>
<li>
<a href=#spatial-complexity aria-label="Spatial Complexity">Spatial Complexity</a></li>
<li>
<a href=#time-complexity aria-label="Time Complexity">Time Complexity</a></li></ul>
</li>
<li>
<a href=#what-is-a-good-algorithm aria-label="What is a Good Algorithm?">What is a Good Algorithm?</a><ul>
<li>
<a href=#why-focus-on-the-worst-case aria-label="Why focus on the worst case?">Why focus on the worst case?</a></li></ul>
</li>
<li>
<a href=#progressive-representation-of-complexity aria-label="Progressive Representation of Complexity">Progressive Representation of Complexity</a><ul>
<li>
<a href=#asymptotic-mark aria-label="Asymptotic mark">Asymptotic mark</a><ul>
<li>
<a href=#symbol-maththetaendmath aria-label="Symbol {%math%}\Theta{%endmath%}">Symbol {%math%}\Theta{%endmath%}</a></li>
<li>
<a href=#symbol-mathoendmath aria-label="Symbol {%math%}O{%endmath%}">Symbol {%math%}O{%endmath%}</a></li>
<li>
<a href=#symbol-mathomegaendmath aria-label="Symbol {%math%}\Omega{%endmath%}">Symbol {%math%}\Omega{%endmath%}</a></li>
<li>
<a href=#symbol-mathoendmath-and-mathomegaendmath aria-label="Symbol {%math%}o{%endmath%} and {%math%}\omega{%endmath%}">Symbol {%math%}o{%endmath%} and {%math%}\omega{%endmath%}</a></li></ul>
</li>
<li>
<a href=#memory-tips aria-label="Memory tips">Memory tips</a></li></ul>
</li>
<li>
<a href=#several-common-time-complexity aria-label="Several common time complexity">Several common time complexity</a></li>
<li>
<a href=#deep-understanding aria-label="Deep understanding">Deep understanding</a></li></ul>
</li>
<li>
<a href=#%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6 aria-label=垃圾回收>垃圾回收</a><ul>
<li>
<a href=#%e5%a6%82%e4%bd%95%e5%88%a4%e6%96%ad%e5%af%b9%e8%b1%a1%e5%8f%af%e5%9b%9e%e6%94%b6 aria-label=如何判断对象可回收>如何判断对象可回收</a><ul>
<li>
<a href=#%e5%bc%95%e7%94%a8%e8%ae%a1%e6%95%b0%e6%b3%95 aria-label=引用计数法>引用计数法</a></li>
<li>
<a href=#%e5%8f%af%e8%be%be%e6%80%a7%e5%88%86%e6%9e%90%e6%b3%95 aria-label=可达性分析法>可达性分析法</a></li></ul>
</li>
<li>
<a href=#java%e4%b8%ad%e4%ba%94%e7%a7%8d%e5%bc%95%e7%94%a8 aria-label=Java中五种引用>Java中五种引用</a><ul>
<li>
<a href=#%e5%bc%ba%e5%bc%95%e7%94%a8 aria-label=强引用>强引用</a></li>
<li>
<a href=#%e8%bd%af%e5%bc%95%e7%94%a8 aria-label=软引用>软引用</a></li>
<li>
<a href=#%e5%bc%b1%e5%bc%95%e7%94%a8 aria-label=弱引用>弱引用</a></li>
<li>
<a href=#%e8%99%9a%e5%bc%95%e7%94%a8 aria-label=虚引用>虚引用</a></li>
<li>
<a href=#%e7%bb%88%e7%bb%93%e5%99%a8 aria-label=终结器>终结器</a></li></ul>
</li>
<li>
<a href=#%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e7%ae%97%e6%b3%95 aria-label=垃圾回收算法>垃圾回收算法</a><ul>
<li>
<a href=#%e6%a0%87%e8%ae%b0%e6%b8%85%e9%99%a4%e7%ae%97%e6%b3%95mark-sweep aria-label="标记清除算法(Mark Sweep)">标记清除算法(Mark Sweep)</a></li>
<li>
<a href=#%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86%e7%ae%97%e6%b3%95mark-compact aria-label="标记整理算法(Mark Compact)">标记整理算法(Mark Compact)</a></li>
<li>
<a href=#%e5%a4%8d%e5%88%b6%e7%ae%97%e6%b3%95copying aria-label=复制算法(copying)>复制算法(copying)</a></li></ul>
</li>
<li>
<a href=#jvm-%e8%bf%90%e8%a1%8c%e6%97%b6%e5%86%85%e5%ad%98 aria-label="JVM 运行时内存">JVM 运行时内存</a><ul>
<li>
<a href=#%e6%96%b0%e7%94%9f%e4%bb%a3 aria-label=新生代>新生代</a><ul>
<li>
<a href=#eden aria-label=Eden>Eden</a></li>
<li>
<a href=#servivorfrom aria-label=ServivorFrom>ServivorFrom</a></li>
<li>
<a href=#servivorto aria-label=ServivorTo>ServivorTo</a></li>
<li>
<a href=#minorgc%e7%9a%84%e8%bf%87%e7%a8%8b%e5%a4%8d%e5%88%b6-%e6%b8%85%e7%a9%ba-%e4%ba%92%e6%8d%a2 aria-label=MinorGC的过程（复制-&amp;gt;清空-&amp;gt;互换）>MinorGC的过程（复制->清空->互换）</a></li></ul>
</li>
<li>
<a href=#%e8%80%81%e5%b9%b4%e4%bb%a3 aria-label=老年代>老年代</a></li>
<li>
<a href=#%e6%b0%b8%e4%b9%85%e4%bb%a3 aria-label=永久代>永久代</a></li></ul>
</li>
<li>
<a href=#%e5%88%86%e4%bb%a3%e6%94%b6%e9%9b%86%e7%ae%97%e6%b3%95 aria-label=分代收集算法>分代收集算法</a><ul>
<li>
<a href=#%e6%96%b0%e7%94%9f%e4%bb%a3%e4%b8%8e%e5%a4%8d%e5%88%b6%e7%ae%97%e6%b3%95 aria-label=新生代与复制算法>新生代与复制算法</a></li>
<li>
<a href=#%e8%80%81%e5%b9%b4%e4%bb%a3%e4%b8%8e%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86%e7%ae%97%e6%b3%95 aria-label=老年代与标记整理算法>老年代与标记整理算法</a></li></ul>
</li>
<li>
<a href=#%e5%88%86%e4%bb%a3%e6%94%b6%e9%9b%86%e7%ae%97%e6%b3%95-vs-%e5%88%86%e5%8c%ba%e6%94%b6%e9%9b%86%e7%ae%97%e6%b3%95 aria-label="分代收集算法 VS 分区收集算法">分代收集算法 VS 分区收集算法</a><ul>
<li>
<a href=#%e5%88%86%e4%bb%a3%e6%94%b6%e9%9b%86%e7%ae%97%e6%b3%95-1 aria-label=分代收集算法>分代收集算法</a><ul>
<li>
<a href=#%e6%96%b0%e7%94%9f%e4%bb%a3%e5%a4%8d%e5%88%b6%e7%ae%97%e6%b3%95 aria-label=新生代——复制算法>新生代——复制算法</a></li>
<li>
<a href=#%e8%80%81%e5%b9%b4%e4%bb%a3%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86%e7%ae%97%e6%b3%95 aria-label=老年代——标记整理算法>老年代——标记整理算法</a></li></ul>
</li>
<li>
<a href=#%e5%88%86%e5%8c%ba%e6%94%b6%e9%9b%86%e7%ae%97%e6%b3%95 aria-label=分区收集算法>分区收集算法</a></li>
<li>
<a href=#%e5%88%86%e4%bb%a3%e5%9b%9e%e6%94%b6%e7%9b%b8%e5%85%b3%e5%8f%82%e6%95%b0 aria-label=分代回收相关参数>分代回收相关参数</a></li></ul>
</li>
<li>
<a href=#%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8 aria-label=垃圾收集器>垃圾收集器</a><ul>
<li>
<a href=#serial%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8 aria-label=Serial垃圾收集器>Serial垃圾收集器</a></li>
<li>
<a href=#serial-old%e6%94%b6%e9%9b%86%e5%99%a8 aria-label="Serial Old收集器">Serial Old收集器</a></li>
<li>
<a href=#parnew%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8 aria-label=ParNew垃圾收集器>ParNew垃圾收集器</a></li>
<li>
<a href=#parallel-scavenge%e6%94%b6%e9%9b%86%e5%99%a8 aria-label="Parallel Scavenge收集器">Parallel Scavenge收集器</a></li>
<li>
<a href=#parallel-old%e6%94%b6%e9%9b%86%e5%99%a8 aria-label="Parallel Old收集器">Parallel Old收集器</a></li>
<li>
<a href=#cms%e6%94%b6%e9%9b%86%e5%99%a8 aria-label=CMS收集器>CMS收集器</a><ul>
<li>
<a href=#%e5%88%9d%e5%a7%8b%e6%a0%87%e8%ae%b0-%e9%80%9f%e5%ba%a6%e5%bf%ab aria-label="初始标记 速度快">初始标记 <code>速度快</code></a></li>
<li>
<a href=#%e5%b9%b6%e5%8f%91%e6%a0%87%e8%ae%b0-%e9%80%9f%e5%ba%a6%e6%85%a2 aria-label="并发标记 速度慢">并发标记 <code>速度慢</code></a></li>
<li>
<a href=#%e9%87%8d%e6%96%b0%e6%a0%87%e8%ae%b0-%e9%80%9f%e5%ba%a6%e5%bf%ab aria-label="重新标记 速度快">重新标记 <code>速度快</code></a></li>
<li>
<a href=#%e5%b9%b6%e5%8f%91%e6%b8%85%e9%99%a4-%e9%80%9f%e5%ba%a6%e6%85%a2 aria-label="并发清除 速度慢">并发清除 <code>速度慢</code></a></li></ul>
</li>
<li>
<a href=#g1%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e5%99%a8 aria-label=G1垃圾回收器>G1垃圾回收器</a><ul>
<li>
<a href=#g1%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e9%98%b6%e6%ae%b5 aria-label=G1垃圾回收阶段>G1垃圾回收阶段</a></li>
<li>
<a href=#young-collection aria-label="Young Collection">Young Collection</a></li>
<li>
<a href=#young-collection--cm aria-label="Young Collection + CM">Young Collection + CM</a></li>
<li>
<a href=#%e6%b7%b7%e5%90%88%e6%94%b6%e9%9b%86 aria-label=混合收集>混合收集</a></li>
<li>
<a href=#young-collection-%e8%b7%a8%e4%bb%a3%e5%bc%95%e7%94%a8 aria-label="Young Collection 跨代引用">Young Collection 跨代引用</a></li>
<li>
<a href=#jdk-8u20-%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%8e%bb%e9%87%8d aria-label="JDK 8u20 字符串去重">JDK 8u20 字符串去重</a></li>
<li>
<a href=#jdk-8u40-%e5%b9%b6%e5%8f%91%e6%a0%87%e8%ae%b0%e7%b1%bb%e5%8d%b8%e8%bd%bd aria-label="JDK 8u40 并发标记类卸载">JDK 8u40 并发标记类卸载</a></li>
<li>
<a href=#jdk-8u60-%e5%9b%9e%e6%94%b6%e5%b7%a8%e5%9e%8b%e5%af%b9%e8%b1%a1 aria-label="JDK 8u60 回收巨型对象">JDK 8u60 回收巨型对象</a></li>
<li>
<a href=#jdk-9-%e5%b9%b6%e5%8f%91%e6%a0%87%e8%ae%b0%e8%b5%b7%e5%a7%8b%e6%97%b6%e9%97%b4%e7%9a%84%e8%b0%83%e6%95%b4 aria-label="JDK 9 并发标记起始时间的调整">JDK 9 并发标记起始时间的调整</a></li>
<li>
<a href=#jdk-9-%e6%9b%b4%e9%ab%98%e6%95%88%e7%9a%84%e5%9b%9e%e6%94%b6 aria-label="JDK 9 更高效的回收">JDK 9 更高效的回收</a></li></ul>
</li>
<li>
<a href=#remark-%e8%be%a8%e6%9e%90 aria-label="Remark 辨析">Remark 辨析</a></li>
<li>
<a href=#full-gc-%e8%be%a8%e6%9e%90 aria-label="Full GC 辨析">Full GC 辨析</a><ul>
<li>
<a href=#serialgc aria-label=SerialGC>SerialGC</a></li>
<li>
<a href=#parallelgc aria-label=ParallelGC>ParallelGC</a></li>
<li>
<a href=#cms aria-label=CMS>CMS</a></li>
<li>
<a href=#g1 aria-label=G1>G1</a></li></ul>
</li>
<li>
<a href=#%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e5%99%a8%e7%9b%b8%e5%85%b3%e5%8f%82%e6%95%b0 aria-label=垃圾回收器相关参数>垃圾回收器相关参数</a><ul>
<li>
<a href=#%e4%b8%b2%e8%a1%8c aria-label=串行>串行</a></li>
<li>
<a href=#%e5%90%9e%e5%90%90%e9%87%8f%e4%bc%98%e5%85%88 aria-label=吞吐量优先>吞吐量优先</a></li>
<li>
<a href=#%e5%93%8d%e5%ba%94%e6%97%b6%e9%97%b4%e4%bc%98%e5%85%88 aria-label=响应时间优先>响应时间优先</a></li></ul>
</li></ul>
</li>
<li>
<a href=#gc-%e8%b0%83%e4%bc%98 aria-label="GC 调优">GC 调优</a><ul>
<li>
<a href=#%e8%b0%83%e4%bc%98%e9%a2%86%e5%9f%9f aria-label=调优领域>调优领域</a></li>
<li>
<a href=#%e8%b0%83%e4%bc%98%e7%9b%ae%e6%a0%87 aria-label=调优目标>调优目标</a></li>
<li>
<a href=#%e6%9c%80%e5%bf%ab%e7%9a%84-gc-%e6%98%af%e4%b8%8d%e5%8f%91%e7%94%9f-gc aria-label="最快的 GC 是不发生 GC">最快的 GC 是不发生 GC</a></li>
<li>
<a href=#%e6%96%b0%e7%94%9f%e4%bb%a3%e8%b0%83%e4%bc%98 aria-label=新生代调优>新生代调优</a></li>
<li>
<a href=#%e8%80%81%e5%b9%b4%e4%bb%a3%e8%b0%83%e4%bc%98 aria-label=老年代调优>老年代调优</a></li>
<li>
<a href=#%e6%a1%88%e4%be%8b aria-label=案例>案例</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p>The following HTML <code>&lt;h1></code>—<code>&lt;h6></code> elements represent six levels of section headings. <code>&lt;h1></code> is the highest section level while <code>&lt;h6></code> is the lowest.</p>
<h1 id=h1>H1<a hidden class=anchor aria-hidden=true href=#h1>#</a></h1>
<h2 id=h2>H2<a hidden class=anchor aria-hidden=true href=#h2>#</a></h2>
<h3 id=h3>H3<a hidden class=anchor aria-hidden=true href=#h3>#</a></h3>
<h4 id=h4>H4<a hidden class=anchor aria-hidden=true href=#h4>#</a></h4>
<h5 id=h5>H5<a hidden class=anchor aria-hidden=true href=#h5>#</a></h5>
<h6 id=h6>H6<a hidden class=anchor aria-hidden=true href=#h6>#</a></h6>
<h2 id=paragraph>Paragraph<a hidden class=anchor aria-hidden=true href=#paragraph>#</a></h2>
<p>Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.</p>
<p>Itatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.</p>
<h2 id=blockquotes>Blockquotes<a hidden class=anchor aria-hidden=true href=#blockquotes>#</a></h2>
<p>The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a <code>footer</code> or <code>cite</code> element, and optionally with in-line changes such as annotations and abbreviations.</p>
<h4 id=blockquote-without-attribution>Blockquote without attribution<a hidden class=anchor aria-hidden=true href=#blockquote-without-attribution>#</a></h4>
<blockquote>
<p>Tiam, ad mint andaepu dandae nostion secatur sequo quae.
<strong>Note</strong> that you can use <em>Markdown syntax</em> within a blockquote.</p>
</blockquote>
<h4 id=blockquote-with-attribution>Blockquote with attribution<a hidden class=anchor aria-hidden=true href=#blockquote-with-attribution>#</a></h4>
<blockquote>
<p>Don&rsquo;t communicate by sharing memory, share memory by communicating.</p>
<p>— <cite>Rob Pike<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></cite></p>
</blockquote>
<h2 id=tables>Tables<a hidden class=anchor aria-hidden=true href=#tables>#</a></h2>
<p>Tables aren&rsquo;t part of the core Markdown spec, but Hugo supports them out-of-the-box.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Age</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bob</td>
<td>27</td>
</tr>
<tr>
<td>Alice</td>
<td>23</td>
</tr>
</tbody>
</table>
<h4 id=inline-markdown-within-tables>Inline Markdown within tables<a hidden class=anchor aria-hidden=true href=#inline-markdown-within-tables>#</a></h4>
<table>
<thead>
<tr>
<th>Italics</th>
<th>Bold</th>
<th>Code</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>italics</em></td>
<td><strong>bold</strong></td>
<td><code>code</code></td>
</tr>
</tbody>
</table>
<h2 id=code-blocks>Code Blocks<a hidden class=anchor aria-hidden=true href=#code-blocks>#</a></h2>
<h4 id=code-block-with-backticks>Code block with backticks<a hidden class=anchor aria-hidden=true href=#code-block-with-backticks>#</a></h4>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=color:#75715e>&lt;!DOCTYPE html&gt;</span>
&lt;<span style=color:#f92672>html</span> <span style=color:#a6e22e>lang</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;en&#34;</span>&gt;
    &lt;<span style=color:#f92672>head</span>&gt;
        &lt;<span style=color:#f92672>meta</span> <span style=color:#a6e22e>charset</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;utf-8&#34;</span> /&gt;
        &lt;<span style=color:#f92672>title</span>&gt;Example HTML5 Document&lt;/<span style=color:#f92672>title</span>&gt;
    &lt;/<span style=color:#f92672>head</span>&gt;
    &lt;<span style=color:#f92672>body</span>&gt;
        &lt;<span style=color:#f92672>p</span>&gt;Test&lt;/<span style=color:#f92672>p</span>&gt;
    &lt;/<span style=color:#f92672>body</span>&gt;
&lt;/<span style=color:#f92672>html</span>&gt;
</code></pre></div><h4 id=code-block-indented-with-four-spaces>Code block indented with four spaces<a hidden class=anchor aria-hidden=true href=#code-block-indented-with-four-spaces>#</a></h4>
<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;Example HTML5 Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;Test&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id=code-block-with-hugos-internal-highlight-shortcode>Code block with Hugo&rsquo;s internal highlight shortcode<a hidden class=anchor aria-hidden=true href=#code-block-with-hugos-internal-highlight-shortcode>#</a></h4>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=color:#75715e>&lt;!doctype html&gt;</span>
&lt;<span style=color:#f92672>html</span> <span style=color:#a6e22e>lang</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;en&#34;</span>&gt;
&lt;<span style=color:#f92672>head</span>&gt;
  &lt;<span style=color:#f92672>meta</span> <span style=color:#a6e22e>charset</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;utf-8&#34;</span>&gt;
  &lt;<span style=color:#f92672>title</span>&gt;Example HTML5 Document&lt;/<span style=color:#f92672>title</span>&gt;
&lt;/<span style=color:#f92672>head</span>&gt;
&lt;<span style=color:#f92672>body</span>&gt;
  &lt;<span style=color:#f92672>p</span>&gt;Test&lt;/<span style=color:#f92672>p</span>&gt;
&lt;/<span style=color:#f92672>body</span>&gt;
&lt;/<span style=color:#f92672>html</span>&gt;</code></pre></div>
<h4 id=gist>Gist<a hidden class=anchor aria-hidden=true href=#gist>#</a></h4>
<script type=application/javascript src=https://gist.github.com/spf13/7896402.js></script>
<h2 id=list-types>List Types<a hidden class=anchor aria-hidden=true href=#list-types>#</a></h2>
<h4 id=ordered-list>Ordered List<a hidden class=anchor aria-hidden=true href=#ordered-list>#</a></h4>
<ol>
<li>First item</li>
<li>Second item</li>
<li>Third item</li>
</ol>
<h4 id=unordered-list>Unordered List<a hidden class=anchor aria-hidden=true href=#unordered-list>#</a></h4>
<ul>
<li>List item</li>
<li>Another item</li>
<li>And another item</li>
</ul>
<h4 id=nested-list>Nested list<a hidden class=anchor aria-hidden=true href=#nested-list>#</a></h4>
<ul>
<li>Fruit
<ul>
<li>Apple</li>
<li>Orange</li>
<li>Banana</li>
</ul>
</li>
<li>Dairy
<ul>
<li>Milk</li>
<li>Cheese</li>
</ul>
</li>
</ul>
<h2 id=other-elements--abbr-sub-sup-kbd-mark>Other Elements — abbr, sub, sup, kbd, mark<a hidden class=anchor aria-hidden=true href=#other-elements--abbr-sub-sup-kbd-mark>#</a></h2>
<p><abbr title="Graphics Interchange Format">GIF</abbr> is a bitmap image format.</p>
<p>H<sub>2</sub>O</p>
<p>X<sup>n</sup> + Y<sup>n</sup> = Z<sup>n</sup></p>
<p>Press <kbd><kbd>CTRL</kbd>+<kbd>ALT</kbd>+<kbd>Delete</kbd></kbd> to end the session.</p>
<p>Most <mark>salamanders</mark> are nocturnal, and hunt for insects, worms, and other small creatures.
Drafts do not get deployed; once you finish a post, update the header of the post to say draft: false. More info here.
$$
\begin{pmatrix}
a & b \\
c & d
\end{pmatrix}
$$</p>
<h2 id=type-of-complexity>Type of Complexity<a hidden class=anchor aria-hidden=true href=#type-of-complexity>#</a></h2>
<h3 id=spatial-complexity>Spatial Complexity<a hidden class=anchor aria-hidden=true href=#spatial-complexity>#</a></h3>
<p>The spatial complexity $$\mathring{g}$$ {%math%}S(n){%endmath%} is the length of the storage unit that is occupied by the program written according to the algorithm.</p>
<p>This length is often related to the size of the input data. An algorithm with too much space complexity may cause memory overruns to be used, causing abnormal program interruption.</p>
<h3 id=time-complexity>Time Complexity<a hidden class=anchor aria-hidden=true href=#time-complexity>#</a></h3>
<p>The time complexity {%math%}T(n){%endmath%} is the length of time that the program written according to the algorithm takes time to execute.</p>
<p>This length is also often related to the size of the input data. Inefficient algorithms with excessive time complexity may cause us to wait for the results of our operations for the rest of our lives.</p>
<h2 id=what-is-a-good-algorithm>What is a Good Algorithm?<a hidden class=anchor aria-hidden=true href=#what-is-a-good-algorithm>#</a></h2>
<p>When analyzing the efficiency of general algorithms, we often pay attention to the following two kinds of complexity:</p>
<ul>
<li>
<p>Worst case complexity {%math%}T_{worst}(n){%endmath%};</p>
</li>
<li>
<p>Average complexity {%math%}T_{avg}(n){%endmath%}.</p>
</li>
</ul>
<p>{%math%}</p>
<p>T_{avg}(n) \le T_{worst}(n)</p>
<p>{%endmath%}</p>
<h3 id=why-focus-on-the-worst-case>Why focus on the worst case?<a hidden class=anchor aria-hidden=true href=#why-focus-on-the-worst-case>#</a></h3>
<ul>
<li>
<p>The worst case gives the upper bound on the execution time of the algorithm. We can be sure that the execution time of the algorithm will not exceed this upper bound no matter what input is given, which facilitates comparison and analysis.</p>
</li>
<li>
<p>For some algorithms, the worst case is the most common case, such as the algorithm for finding a certain information in the database. The worst case is that the information does not exist in the database at all, and it is not found. And some applications often have to find a message that does not exist in the database.</p>
</li>
<li>
<p>Although the worst case is a pessimistic estimate, for many problems, the average case and the worst case time complexity are similar, such as insertion ordering, averaging and worst case time complexity are quadratic functions of input length {%math%}n{%endmath%}.</p>
</li>
</ul>
<h2 id=progressive-representation-of-complexity>Progressive Representation of Complexity<a hidden class=anchor aria-hidden=true href=#progressive-representation-of-complexity>#</a></h2>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/Complexity/20200404172539.png width=60%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px">Progressive Representation</div>
</center>
<h3 id=asymptotic-mark>Asymptotic mark<a hidden class=anchor aria-hidden=true href=#asymptotic-mark>#</a></h3>
<h4 id=symbol-maththetaendmath>Symbol {%math%}\Theta{%endmath%}<a hidden class=anchor aria-hidden=true href=#symbol-maththetaendmath>#</a></h4>
<p>The {%math%}\Theta{%endmath%} mark progressively gives the upper and lower bounds of a function. If there are normal quantities {%math%}c_1{%endmath%} and {%math%}c_2{%endmath%}, so that for a sufficiently large {%math%}n{%endmath%}, the function {%math%}f(n){%endmath%} can be sandwiched between {%math%}c_1g(n){%endmath%} and {%math%}c_2g(n){%endmath%}, that is, {%math%}f(n){%endmath%} and {%math%}\Theta(g(n)){%endmath%} are The same magnitude. We usually write &ldquo;{%math%}f(n)=\Theta(g(n)){%endmath%}&rdquo; to express the same concept.</p>
<h4 id=symbol-mathoendmath>Symbol {%math%}O{%endmath%}<a hidden class=anchor aria-hidden=true href=#symbol-mathoendmath>#</a></h4>
<p>{%math%}O{%endmath%} read as large {%math%}O(g(n)){%endmath%}, sometimes only read as {%math%}O(g(n)){%endmath%} gives a progressive upper bound on a function.</p>
<h4 id=symbol-mathomegaendmath>Symbol {%math%}\Omega{%endmath%}<a hidden class=anchor aria-hidden=true href=#symbol-mathomegaendmath>#</a></h4>
<p>The {%math%}\Omega{%endmath%} token gives the progressive lower bound of a function.</p>
<h4 id=symbol-mathoendmath-and-mathomegaendmath>Symbol {%math%}o{%endmath%} and {%math%}\omega{%endmath%}<a hidden class=anchor aria-hidden=true href=#symbol-mathoendmath-and-mathomegaendmath>#</a></h4>
<p>There are also {%math%}o{%endmath%} marks and {%math%}\omega{%endmath%} marks, which represent a non-progressively accurate upper bound and a non-progressively tight lower bound.</p>
<h3 id=memory-tips>Memory tips<a hidden class=anchor aria-hidden=true href=#memory-tips>#</a></h3>
<ul>
<li>The meaning of {%math%}\Theta{%endmath%} is similar to “equal to”;</li>
<li>The meaning of {%math%}O{%endmath%} is similar to &ldquo;less than or equal to&rdquo;;</li>
<li>The meaning of {%math%}\Omega{%endmath%} is similar to &ldquo;greater than or equal to&rdquo;;</li>
<li>The meaning of {%math%}o{%endmath%} is similar to &ldquo;less than&rdquo;;</li>
<li>The meaning of {%math%}\omega{%endmath%} is similar to &ldquo;greater than&rdquo;;</li>
</ul>
<h2 id=several-common-time-complexity>Several common time complexity<a hidden class=anchor aria-hidden=true href=#several-common-time-complexity>#</a></h2>
<p><img loading=lazy src=https://raw.githubusercontent.com/liugangjian/blogImag/master/Complexity/20200404172806.png alt=我们一般需>
</p>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/Complexity/20200404172806.png width=100%>
<p>
</center>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/Complexity/20200404173133.png width=100%>
<p>
</center>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/Complexity/20200404173231.png width=100%>
<p>
</center>
<h2 id=deep-understanding>Deep understanding<a hidden class=anchor aria-hidden=true href=#deep-understanding>#</a></h2>
<ol>
<li><a href=http://open.163.com/movie/2010/12/2/E/M6UTT5U0I_M6V2T4T2E.html>Introduction to MIT Algorithm: Asymptotic Symbol, Recursion and Solution</a>
<object width=640 height=360><param name=movie value="//open.163.com/openplayer/-M6UTT5U0I-M6V2T4T2E-http://open-image.nosdn.127.net/4a92877fb47f409f8ca2c28b00da9c5d.jpg-openPlayer.swf?isUserAutoPlay=1"></param><param name=allowScriptAccess value=always></param><param name=wmode value=transparent></param><embed src="//open.163.com/openplayer/-M6UTT5U0I-M6V2T4T2E-http://open-image.nosdn.127.net/4a92877fb47f409f8ca2c28b00da9c5d.jpg-openPlayer.swf?isUserAutoPlay=1" type=application/x-shockwave-flash width=640 height=360 allowfullscreen wmode=transparent allowscriptaccess=always></embed></object></li>
</ol>
<h1 id=垃圾回收>垃圾回收<a hidden class=anchor aria-hidden=true href=#垃圾回收>#</a></h1>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/0.jpg width=100%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px"></div>
</center>
<h2 id=如何判断对象可回收>如何判断对象可回收<a hidden class=anchor aria-hidden=true href=#如何判断对象可回收>#</a></h2>
<h3 id=引用计数法>引用计数法<a hidden class=anchor aria-hidden=true href=#引用计数法>#</a></h3>
<p>在Java中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说，即<strong>一个对象如果没有任何与之关联的引用，即他们的引用计数都不为0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。</strong></p>
<p>但是可能存在循环引用的问题，两个对象之间相互引用，再没有其他对象引用他们，但这两个对象都会因计数不为零而无法进行回收，造成内存泄漏。</p>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/1.png width=50%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px"></div>
</center>
<h3 id=可达性分析法>可达性分析法<a hidden class=anchor aria-hidden=true href=#可达性分析法>#</a></h3>
<p>为了解决引用计数法的循环引用问题，Java使用了可达性分析的方法。通过一系列的“GC roots”对象作为起点搜索。<strong>如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。</strong></p>
<p>要注意的是，<strong>不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。</strong></p>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/2.png width=100%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px">可以用eclipse提供的工具进行查看</div>
</center>
<h2 id=java中五种引用>Java中五种引用<a hidden class=anchor aria-hidden=true href=#java中五种引用>#</a></h2>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/3.png width=100%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px"></div>
</center>
<h3 id=强引用>强引用<a hidden class=anchor aria-hidden=true href=#强引用>#</a></h3>
<p>上图中A1对象为强引用。</p>
<p>它在Java中最常见的就是强引用，**把一个对象赋给一个引用变量，这个引用变量就是一个强引用。**当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成Java内存泄漏的主要原因之一。</p>
<ul>
<li>只有所有 GC Roots 对象都不通过<code>强引用</code>引用该对象，该对象才能被垃圾回收</li>
</ul>
<h3 id=软引用>软引用<a hidden class=anchor aria-hidden=true href=#软引用>#</a></h3>
<p>上图A2对象为软引用。</p>
<p>软引用需要用<code>SoftReference类</code>来实现，对于只有软引用的对象来说，**当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。**软引用通常用在对内存敏感的程序中。</p>
<p>由于软引用自身也是一个对象，也需要占用一部分的内存，如果软引用在创建时，给他分配了一个<code>引用队列</code>，那么在软引用所引用的对象被垃圾回收时，软引用对象会进入引用队列，等待队列的遍历释放这部分的内存。</p>
<ul>
<li>仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象</li>
<li><strong>可以</strong>配合引用队列来释放软引用自身</li>
</ul>
<h3 id=弱引用>弱引用<a hidden class=anchor aria-hidden=true href=#弱引用>#</a></h3>
<p>上图A3对象为弱引用。</p>
<p>弱引用需要用<code>WeakReference类</code>来实现，它比软引用的生存期更短，<strong>对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，总会回收该对象占用的内存。</strong></p>
<p>弱引用对象的释放和软引用相同：</p>
<p>由于弱引用自身也是一个对象，也需要占用一部分的内存，如果弱引用在创建时，给他分配了一个<code>引用队列</code>，那么在弱引用所引用的对象被垃圾回收时，弱引用对象会进入引用队列，等待队列的遍历释放这部分的内存。</p>
<ul>
<li>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</li>
<li><strong>可以</strong>配合引用队列来释放弱引用自身</li>
</ul>
<h3 id=虚引用>虚引用<a hidden class=anchor aria-hidden=true href=#虚引用>#</a></h3>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/4.png width=100%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px"></div>
</center>
<p>虚引用需要<code>PhantomReference类</code>来实现，它不能单独使用，也必须和<code>引用队列</code>联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。</p>
<p>比如在内存结构中的直接内存章节，在创建ByteBuffer实现类对象时，会自动创建一个名为Cleaner的虚引用对象指向直接内存的地址。当将来没有强引用指向ByteBuffer时，ByteBuffer对象会被回收，但是分配的直接内存并不能被Java回收。</p>
<p>在ByteBuffer被回收的时候，虚引用对象进入引用队列，而虚引用所在的引用队列，会有一个线程检查看有没有一个新入队的Cleaner，如果有则会调用虚引用中的clean方法，用Unsafe.freeMemory将直接内存释放掉，这样避免了直接内存的内存泄露问题，之后将虚引用对象回收掉。</p>
<ul>
<li><strong>必须</strong>配合<code>引用队列</code>使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存</li>
</ul>
<h3 id=终结器>终结器<a hidden class=anchor aria-hidden=true href=#终结器>#</a></h3>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/5.png width=100%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px"></div>
</center>
<p>上图A4对象为终结器引用。</p>
<p>所有的Java对象都继承自Object父类，而Object类中都有finallize()方法（终结方法），如果对象重写了终结方法并且没有强引用引用它时，<strong>虚拟机会创建该对象的终结器引用</strong>，当对象发生垃圾回收时，该对象的终结器引用会加入引用队列中，再由一个优先级很低的线程查看在队列中是否存在终结器引用，根据终结器引用找到待回收的对象并调用它的finallize()方法。之后将终结器引用对象回收掉。</p>
<p>不过我们发现finallize()方法的工作效率很低，他在第一次回收时，并不能立即释放掉而是先入队，而且处理队列的线程的优先级很低，这就导致了对象的finallize()方法迟迟得不到调用，该对象所占用的资源迟迟得不到释放，所以并不推荐使用finallize()方法去释放资源。</p>
<ul>
<li>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize方法，第二次 GC 时才能回收被引用对象</li>
</ul>
<h2 id=垃圾回收算法>垃圾回收算法<a hidden class=anchor aria-hidden=true href=#垃圾回收算法>#</a></h2>
<h3 id=标记清除算法mark-sweep>标记清除算法(Mark Sweep)<a hidden class=anchor aria-hidden=true href=#标记清除算法mark-sweep>#</a></h3>
<p>最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。如图所示。</p>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/6.png width=60%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px"></div>
</center>
<p>从图中我们就可以发现，<strong>该算法最大的问题是内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题。</strong></p>
<h3 id=标记整理算法mark-compact>标记整理算法(Mark Compact)<a hidden class=anchor aria-hidden=true href=#标记整理算法mark-compact>#</a></h3>
<p>标记阶段和标记清除算法Mark-Sweep算法相同，标记后不是清理对象，而是将存活对象移向内存的一端，然后清除端边界外的对象。**优点是内存碎片化的问题得以解决，缺点是由于在清理的过程中存在对象的移动，需要改变这些对象的引用地址，使得效率较低，速度慢。**如图：</p>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/7.png width=100%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px"></div>
</center>
<h3 id=复制算法copying>复制算法(copying)<a hidden class=anchor aria-hidden=true href=#复制算法copying>#</a></h3>
<p>为了解决Mark-Sweep算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为<strong>等大小</strong>的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉，如图：</p>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/8.png width=100%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px"></div>
</center>
<p><strong>这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，Copying算法的效率会大大降低。</strong></p>
<ul>
<li>不会有内存碎片</li>
<li>需要双倍的内存空间</li>
</ul>
<h2 id=jvm-运行时内存>JVM 运行时内存<a hidden class=anchor aria-hidden=true href=#jvm-运行时内存>#</a></h2>
<p>Java堆从GC的角度还可以细分为: <strong>新生代</strong>(<code>Eden区</code>、<code>From Survivor区</code>和<code>To Survivor区</code>)和<strong>老年代</strong>。</p>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/9.jpg width=100%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px"></div>
</center>
<h3 id=新生代>新生代<a hidden class=anchor aria-hidden=true href=#新生代>#</a></h3>
<p>是用来存放新生的对象。一般占据堆的1/3空间。由于频繁创建对象，所以新生代会频繁触发<code>MinorGC</code>进行垃圾回收。新生代又分为 <code>Eden区</code>、<code>ServivorFrom</code>、<code>ServivorTo</code>三个区。</p>
<h4 id=eden>Eden<a hidden class=anchor aria-hidden=true href=#eden>#</a></h4>
<p>Java新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行一次垃圾回收。</p>
<h4 id=servivorfrom>ServivorFrom<a hidden class=anchor aria-hidden=true href=#servivorfrom>#</a></h4>
<p>上一次GC的幸存者，作为这一次GC的被扫描者。</p>
<h4 id=servivorto>ServivorTo<a hidden class=anchor aria-hidden=true href=#servivorto>#</a></h4>
<p>保留了一次MinorGC过程中的幸存者。</p>
<h4 id=minorgc的过程复制-清空-互换>MinorGC的过程（复制->清空->互换）<a hidden class=anchor aria-hidden=true href=#minorgc的过程复制-清空-互换>#</a></h4>
<p>MinorGC采用<code>复制算法</code>。</p>
<ol>
<li><strong><code>eden</code>、<code>servicorFrom</code> 复制到<code>ServicorTo</code>，年龄+1</strong>
首先，把Eden和ServivorFrom区域中存活的对象复制到ServicorTo区域（如果有对象的年龄以及达到了老年的标准，则复制到老年代区），同时把这些对象的年龄+1（如果ServicorTo不够位置了就放到老年区）；</li>
<li><strong>清空eden、servicorFrom</strong>
然后，清空Eden和ServicorFrom中的对象；</li>
<li><strong><code>ServicorTo</code>和<code>ServicorFrom</code>互换</strong>
最后，ServicorTo和ServicorFrom互换，原ServicorTo成为下一次GC时的ServicorFrom区。</li>
</ol>
<h3 id=老年代>老年代<a hidden class=anchor aria-hidden=true href=#老年代>#</a></h3>
<p>主要存放应用程序中生命周期长的内存对象。</p>
<p>老年代的对象比较稳定，所以Full/Major GC不会频繁执行。**在进行MajorGC前一般都先进行了一次MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。**当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间。MajorGC的速度会比MinorGC慢十倍以上。</p>
<p>MajorGC采用<code>标记清除算法</code>：首先扫描一次所有<code>老年代</code>，标记出存活的对象，然后回收没有标记的对象。MajorGC的耗时比较长，因为要扫描再回收。MajorGC会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常。</p>
<p>触发机制：</p>
<ul>
<li>当年轻代满时就会触发Minor GC,这里的年轻代是指Eden区满，Survivor区满不会引发.</li>
<li>当老年代满的时候，会触发Full GC，<strong>同时回收年轻代，年老代</strong>，当永久代满了以后也会触发Full GC.</li>
</ul>
<h3 id=永久代>永久代<a hidden class=anchor aria-hidden=true href=#永久代>#</a></h3>
<p>指内存的永久保存区域，主要存放Class和Meta（元数据）的信息,Class在被加载的时候被放入永久区域，它和存放实例的区域不同,GC不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常。</p>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/20200404191013.png width=70%>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/20200404191052.png width=70%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px"></div>
</center>
<p>在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。</p>
<p>类的元数据放入 native memory, 字符串池和类的静态变量放入java堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制。</p>
<h2 id=分代收集算法>分代收集算法<a hidden class=anchor aria-hidden=true href=#分代收集算法>#</a></h2>
<p>分代收集法是目前大部分JVM所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将GC堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)。</p>
<p>老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。</p>
<h3 id=新生代与复制算法>新生代与复制算法<a hidden class=anchor aria-hidden=true href=#新生代与复制算法>#</a></h3>
<p>目前大部分JVM的GC对于新生代都采取Copying算法，<strong>因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照1：1来划分新生代。</strong></p>
<p>一般将新生代划分为<strong>一块较大</strong>的Eden空间和<strong>两个较小</strong>的Survivor空间(From Space, To Space)，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将该两块空间中还存活的对象复制到另一块Survivor空间中。</p>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/10.jpg width=100%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px"></div>
</center>
<h3 id=老年代与标记整理算法>老年代与标记整理算法<a hidden class=anchor aria-hidden=true href=#老年代与标记整理算法>#</a></h3>
<p>老年代因为每次只回收少量对象，因而采用<code>Mark-Compact</code>算法。</p>
<ol>
<li>JAVA虚拟机提到过的处于方法区的永生代(PermanetGeneration)，它用来存储class类，常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。</li>
<li>对象的内存分配主要在新生代的Eden Space和Survivor Space的FromSpace(Survivor目前存放对象的那一块)，少数情况会直接分配到老生代。</li>
<li>当新生代的Eden Space和From Space空间不足时就会发生一次GC，进行GC后，Eden Space和From Space区的存活对象会被挪到To Space，然后将Eden Space和From Space进行清理。</li>
<li>如果To Space无法足够存储某个对象，则将这个对象存储到老生代。</li>
<li>在进行GC后，使用的便是Eden Space和To Space了，如此反复循环。</li>
<li>当对象在Survivor区躲过一次GC后，其年龄就会+1。默认情况下年龄到达15的对象会被移到老生代中。</li>
</ol>
<p>通俗的说：</p>
<ol>
<li>对象首先分配在伊甸园区域</li>
<li>新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1并且交换 from to</li>
<li>minor gc 会引发 <code>stop the world</code>，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li>
<li>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit）</li>
<li>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时间更长</li>
</ol>
<h2 id=分代收集算法-vs-分区收集算法>分代收集算法 VS 分区收集算法<a hidden class=anchor aria-hidden=true href=#分代收集算法-vs-分区收集算法>#</a></h2>
<h3 id=分代收集算法-1>分代收集算法<a hidden class=anchor aria-hidden=true href=#分代收集算法-1>#</a></h3>
<p>当前主流VM垃圾收集都采用”分代收集”(Generational Collection)算法, 这种算法会根据对象存活周期的不同将内存划分为几块, 如JVM中的 新生代、老年代、永久代，这样就可以根据各年代特点分别采用最适当的GC算法。</p>
<h4 id=新生代复制算法>新生代——复制算法<a hidden class=anchor aria-hidden=true href=#新生代复制算法>#</a></h4>
<p>每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集.</p>
<h4 id=老年代标记整理算法>老年代——标记整理算法<a hidden class=anchor aria-hidden=true href=#老年代标记整理算法>#</a></h4>
<p>因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存.</p>
<h3 id=分区收集算法>分区收集算法<a hidden class=anchor aria-hidden=true href=#分区收集算法>#</a></h3>
<p>分区算法则将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收. 这样做的好处是可以控制一次回收多少个小区间 , 根据目标停顿时间, 每次合理地回收若干个小区间(而不是整个堆), 从而减少一次GC所产生的停顿。</p>
<h3 id=分代回收相关参数>分代回收相关参数<a hidden class=anchor aria-hidden=true href=#分代回收相关参数>#</a></h3>
<table>
<thead>
<tr>
<th>名词</th>
<th>指令</th>
</tr>
</thead>
<tbody>
<tr>
<td>堆初始大小</td>
<td>-Xms</td>
</tr>
<tr>
<td>堆最大大小</td>
<td>-Xmx 或 -XX:MaxHeapSize=size</td>
</tr>
<tr>
<td>新生代大小</td>
<td>-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )</td>
</tr>
<tr>
<td>幸存区比例（动态）</td>
<td>-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</td>
</tr>
<tr>
<td>幸存区比例</td>
<td>-XX:SurvivorRatio=ratio</td>
</tr>
<tr>
<td>晋升阈值</td>
<td>-XX:MaxTenuringThreshold=threshold</td>
</tr>
<tr>
<td>晋升详情</td>
<td>-XX:+PrintTenuringDistribution</td>
</tr>
<tr>
<td>GC详情</td>
<td>-XX:+PrintGCDetails -verbose:gc</td>
</tr>
<tr>
<td>Full GC 前 Minor GC</td>
<td>-XX:+ScavengeBeforeFullGC</td>
</tr>
</tbody>
</table>
<h2 id=垃圾收集器>垃圾收集器<a hidden class=anchor aria-hidden=true href=#垃圾收集器>#</a></h2>
<p>Java堆内存被划分为新生代和年老代两部分</p>
<ul>
<li>新生代主要使用复制和标记-清除垃圾回收算法；</li>
<li>年老代主要使用标记-整理垃圾回收算法。</li>
</ul>
<p>因此java虚拟中针对新生代和年老代分别提供了多种不同的垃圾收集器，JDK1.6中Sun HotSpot虚拟机的垃圾收集器如下：</p>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/11.jpg width=100%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px"></div>
</center>
<ol>
<li>
<p>串行</p>
<ul>
<li>单线程</li>
<li>堆内存较小，适合个人电脑</li>
</ul>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/12.png width=100%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px">串行</div>
</center>
</li>
<li>
<p>吞吐量优先</p>
<ul>
<li>让单位时间内，STW 的时间最短 0.2 0.2 = 0.4，垃圾回收时间占比最低，这样就称吞吐量高</li>
</ul>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/13.png width=100%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px">吞吐量优先</div>
</center>
</li>
<li>
<p>响应时间优先</p>
<ul>
<li>多线程</li>
<li>堆内存较大，多核 cpu</li>
<li>尽可能让单次 STW 的时间最短 0.1 0.1 0.1 0.1 0.1 = 0.5</li>
</ul>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/18.png width=100%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px">响应时间优先</div>
</center>
</li>
</ol>
<h3 id=serial垃圾收集器>Serial垃圾收集器<a hidden class=anchor aria-hidden=true href=#serial垃圾收集器>#</a></h3>
<p><code>串行</code>、<code>单线程</code>、<code>复制算法</code></p>
<p>-XX:+UseSerialGC = Serial + SerialOld</p>
<p>Serial（英文连续）是最基本垃圾收集器，使用<strong>复制算法</strong>，曾经是JDK1.3.1之前<code>新生代</code>唯一的垃圾收集器。Serial是一个单线程的收集器，它不但只会使用一个CPU或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。</p>
<p>Serial垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个CPU环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此Serial垃圾收集器依然是java虚拟机运行在Client模式下默认的新生代垃圾收集器。</p>
<h3 id=serial-old收集器>Serial Old收集器<a hidden class=anchor aria-hidden=true href=#serial-old收集器>#</a></h3>
<p><code>串行</code>、<code>单线程</code>、<code>标记整理算法</code></p>
<p>Serial Old是Serial垃圾收集器<code>年老代</code>版本，它同样是个单线程的收集器，使用<strong>标记-整理算法</strong>，这个收集器也主要是运行在Client默认的java虚拟机默认的年老代垃圾收集器。 在Server模式下，主要有两个用途：</p>
<ol>
<li>在JDK1.5之前版本中与新生代的Parallel Scavenge收集器搭配使用。</li>
<li>作为年老代中使用CMS收集器的后备垃圾收集方案。</li>
</ol>
<p>新生代Serial与年老代Serial Old搭配垃圾收集过程图：</p>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/14.jpg width=100%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px"></div>
</center>
<p>新生代Parallel Scavenge收集器与ParNew收集器工作原理类似，都是多线程的收集器，都使用的是复制算法，在垃圾收集过程中都需要暂停所有的工作线程。新生代Parallel Scavenge/ParNew与年老代Serial Old搭配垃圾收集过程图：</p>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/15.jpg width=100%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px"></div>
</center>
<h3 id=parnew垃圾收集器>ParNew垃圾收集器<a hidden class=anchor aria-hidden=true href=#parnew垃圾收集器>#</a></h3>
<p><code>吞吐量优先</code>、<code>复制算法</code>、<code>Serial+多线程</code></p>
<p>ParNew垃圾收集器其实是Serial收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和Serial收集器完全一样，ParNew垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。</p>
<p>ParNew收集器默认开启和CPU数目相同的线程数，可以通过-XX:ParallelGCThreads参数来限制垃圾收集器的线程数。<code>Parallel：平行的</code> ParNew虽然是除了多线程外和Serial收集器几乎完全一样，但是ParNew垃圾收集器是很多java虚拟机运行在Server模式下<code>新生代</code>的默认垃圾收集器。</p>
<h3 id=parallel-scavenge收集器>Parallel Scavenge收集器<a hidden class=anchor aria-hidden=true href=#parallel-scavenge收集器>#</a></h3>
<p><code>吞吐量优先</code>、<code>多线程</code>、<code>复制算法</code>、<code>高效</code></p>
<p>Parallel Scavenge收集器也是一个<code>新生代</code>垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集器，它重点关注的是程序达到一个可控制的吞吐量（Thoughput，CPU用于运行用户代码的时间/CPU总消耗时间，即<strong>吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)</strong>），高吞吐量可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。自适应调节策略也是ParallelScavenge收集器与ParNew收集器的一个重要区别。</p>
<h3 id=parallel-old收集器>Parallel Old收集器<a hidden class=anchor aria-hidden=true href=#parallel-old收集器>#</a></h3>
<p><code>吞吐量优先</code>、<code>多线程</code>、<code>标记整理算法</code></p>
<p>Parallel Old收集器是Parallel Scavenge的<code>年老代</code>版本，使用多线程的标记-整理算法，在JDK1.6才开始提供。</p>
<p>在JDK1.6之前，新生代使用ParallelScavenge收集器只能搭配年老代的Serial Old收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old正是为了在年老代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，可以优先考虑新生代Parallel Scavenge和年老代Parallel Old收集器的搭配策略。</p>
<p>新生代Parallel Scavenge和年老代Parallel Old收集器搭配运行过程图：</p>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/16.jpg width=100%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px"></div>
</center>
<p><strong>不难发现，以上几种垃圾收集器中：</strong></p>
<ul>
<li><strong>新生代采用的都是复制算法</strong></li>
<li><strong>老年代采用的都是标记整理算法</strong></li>
</ul>
<h3 id=cms收集器>CMS收集器<a hidden class=anchor aria-hidden=true href=#cms收集器>#</a></h3>
<p><code>响应时间优先</code>、<code>多线程</code>、<code>标记清除算法</code></p>
<p>Concurrent mark sweep(CMS)收集器是一种<code>年老代</code>垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间，<strong>和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。</strong> 最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。 CMS工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下4个阶段：</p>
<h4 id=初始标记-速度快>初始标记 <code>速度快</code><a hidden class=anchor aria-hidden=true href=#初始标记-速度快>#</a></h4>
<p>只是标记一下GC Roots能直接关联的对象，速度很快，<strong>仍然需要暂停所有的工作线程。</strong></p>
<h4 id=并发标记-速度慢>并发标记 <code>速度慢</code><a hidden class=anchor aria-hidden=true href=#并发标记-速度慢>#</a></h4>
<p>进行GC Roots跟踪的过程，和用户线程一起工作，<strong>不需要暂停工作线程。</strong></p>
<h4 id=重新标记-速度快>重新标记 <code>速度快</code><a hidden class=anchor aria-hidden=true href=#重新标记-速度快>#</a></h4>
<p>为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，<strong>仍然需要暂停所有的工作线程。</strong></p>
<h4 id=并发清除-速度慢>并发清除 <code>速度慢</code><a hidden class=anchor aria-hidden=true href=#并发清除-速度慢>#</a></h4>
<p>清除GC Roots不可达对象，和用户线程一起工作，<strong>不需要暂停工作线程。</strong></p>
<p><strong>由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS收集器的内存回收和用户线程是一起并发地执行。</strong></p>
<p><strong>CMS垃圾回收器存在的最大的问题是：由于采用的是标记清除算法，在回收的过程中可能会产生内存碎片，并且是并发收集，其他线程在执行的过程中会产生浮动垃圾，可能导致并发失败，此时会退化为Seriaold垃圾回收器，采用单线程串行的垃圾回收，如果发生并发失败，则垃圾回收的时间会飙升，不符合响应时间优先的初衷</strong></p>
<p>CMS收集器工作过程：</p>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/17.jpg width=100%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px"></div>
</center>
<h3 id=g1垃圾回收器>G1垃圾回收器<a hidden class=anchor aria-hidden=true href=#g1垃圾回收器>#</a></h3>
<p>Garbage first垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与CMS收集器，G1收集器两个最突出的改进是：</p>
<ol>
<li>基于标记-整理算法，不产生内存碎片。</li>
<li>可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。</li>
</ol>
<p>G1收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。<strong>区域划分和优先级区域回收机制，确保G1收集器可以在有限时间获得最高的垃圾收集效率。</strong></p>
<p>定义：Garbage First</p>
<ul>
<li>2004 论文发布</li>
<li>2009 JDK 6u14 体验</li>
<li>2012 JDK 7u4 官方支持</li>
<li>2017 JDK 9 默认</li>
</ul>
<p>适用场景</p>
<ul>
<li>同时注重吞吐量（Throughput）和低延迟（Low latency），默认的暂停目标是 200 ms</li>
<li>超大堆内存，会将堆划分为多个大小相等的 Region</li>
<li>整体上是标记+整理算法，两个区域之间是复制算法</li>
</ul>
<p>随着堆内存的增大，G1回收器较CMS的优势逐渐明显。</p>
<p>相关 JVM 参数</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#f92672>-</span>XX<span style=color:#f92672>:+</span>UseG1GC
<span style=color:#f92672>-</span>XX<span style=color:#f92672>:</span>G1HeapRegionSize<span style=color:#f92672>=</span>size
<span style=color:#f92672>-</span>XX<span style=color:#f92672>:</span>MaxGCPauseMillis<span style=color:#f92672>=</span>time
</code></pre></div><h4 id=g1垃圾回收阶段>G1垃圾回收阶段<a hidden class=anchor aria-hidden=true href=#g1垃圾回收阶段>#</a></h4>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/19.png width=60%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px">循环执行</div>
</center>
<h4 id=young-collection>Young Collection<a hidden class=anchor aria-hidden=true href=#young-collection>#</a></h4>
<ul>
<li>会STW</li>
</ul>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/20.png width=60%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px">初始状态，创建对象放在新生代</div>
</center>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/21.png width=60%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px">发生垃圾回收时，幸存者放入S区</div>
</center>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/23.png width=60%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px">发生垃圾回收时，满足年龄者放入老年代</div>
</center>
<h4 id=young-collection--cm>Young Collection + CM<a hidden class=anchor aria-hidden=true href=#young-collection--cm>#</a></h4>
<p>新生代的垃圾回收和并发标记阶段</p>
<ul>
<li>在 Young GC 时会进行 GC Root 的初始标记</li>
<li>当老年代占用堆空间比例达到阈值时，进行并发标记（不会 STW），由下面的 JVM 参数决定</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#f92672>-</span>XX<span style=color:#f92672>:</span>InitiatingHeapOccupancyPercent<span style=color:#f92672>=</span>percent<span style=color:#f92672>(</span>默认45<span style=color:#f92672>%)</span>
</code></pre></div><center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/24.png width=60%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px">当老年代占堆内存空间的45%时，触发并发标记</div>
</center>
<h4 id=混合收集>混合收集<a hidden class=anchor aria-hidden=true href=#混合收集>#</a></h4>
<ul>
<li>会对 E、S、O 进行全面垃圾回收</li>
<li>最终标记（Remark）会 STW</li>
<li>拷贝存活（Evacuation）会 STW</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#f92672>-</span>XX<span style=color:#f92672>:</span>MaxGCPauseMillis<span style=color:#f92672>=</span>ms
</code></pre></div><center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/25.png width=60%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px">挑选回收区域最高的进行回收来达到最大暂停时间</div>
</center>
<p><strong>Garbage first的含义也是优先收集那些回收价值区域比较大的区块。</strong></p>
<h4 id=young-collection-跨代引用>Young Collection 跨代引用<a hidden class=anchor aria-hidden=true href=#young-collection-跨代引用>#</a></h4>
<p>新生代回收的跨代引用（老年代引用新生代）问题</p>
<ul>
<li>卡表与 Remembered Set</li>
<li>在引用变更时通过 post-write barrier + dirty card queue</li>
<li>concurrent refinement threads 更新 Remembered Set</li>
</ul>
<p>新生代在进行回收时，首先要找到跟对象，然后再进行可达性分析，找到存活对象再进行复制到幸存区等操作。</p>
<p>而跟对象有一部分是来自老年代的，老年代存活的对象是非常多的，因此遍历的效率很低，于是我们采用的是一种卡表的技术，把老年代的区域再进行细分，每一个card占512K，如果老年代其中有一个对象引用了新生代的对象，那我们把该card标记为脏卡。</p>
<p>这样做的好处是我们不用对整个老年代遍历，而只用关心脏卡区域就可以了，这样可以减少搜索范围，提高效率。</p>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/27.png width=80%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px"></div>
</center>
<h4 id=jdk-8u20-字符串去重>JDK 8u20 字符串去重<a hidden class=anchor aria-hidden=true href=#jdk-8u20-字符串去重>#</a></h4>
<ul>
<li>优点：节省大量内存</li>
<li>缺点：略微多占用了 cpu 时间，新生代回收时间略微增加
-XX:+UseStringDeduplication</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>String s1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> String<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;hello&#34;</span><span style=color:#f92672>);</span> <span style=color:#75715e>// char[]{&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;}
</span><span style=color:#75715e></span>String s2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> String<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;hello&#34;</span><span style=color:#f92672>);</span> <span style=color:#75715e>// char[]{&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;}
</span></code></pre></div><ul>
<li>将所有新分配的字符串放入一个队列</li>
<li>当新生代回收时，G1并发检查是否有字符串重复</li>
<li>如果它们值一样，让它们引用同一个 char[]</li>
<li>注意，与 String.intern() 不一样
<ul>
<li>String.intern() 关注的是字符串对象</li>
<li>而字符串去重关注的是 char[]</li>
<li>在 JVM 内部，使用了不同的字符串表</li>
</ul>
</li>
</ul>
<h4 id=jdk-8u40-并发标记类卸载>JDK 8u40 并发标记类卸载<a hidden class=anchor aria-hidden=true href=#jdk-8u40-并发标记类卸载>#</a></h4>
<p>所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类 -XX:+ClassUnloadingWithConcurrentMark 默认启用</p>
<h4 id=jdk-8u60-回收巨型对象>JDK 8u60 回收巨型对象<a hidden class=anchor aria-hidden=true href=#jdk-8u60-回收巨型对象>#</a></h4>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/33.png width=100%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px"></div>
</center>
<ul>
<li>一个对象大于 region 的一半时，称之为巨型对象</li>
<li>G1 不会对巨型对象进行拷贝</li>
<li>回收时被优先考虑</li>
<li>G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生
代垃圾回收时处理掉</li>
</ul>
<h4 id=jdk-9-并发标记起始时间的调整>JDK 9 并发标记起始时间的调整<a hidden class=anchor aria-hidden=true href=#jdk-9-并发标记起始时间的调整>#</a></h4>
<p>并发标记必须在堆空间占满前完成，否则退化为 FullGC</p>
<ul>
<li>JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent</li>
<li>JDK 9 可以动态调整
<ul>
<li>XX:InitiatingHeapOccupancyPercent 用来设置初始值</li>
<li>进行数据采样并动态调整</li>
<li>总会添加一个安全的空档空间</li>
</ul>
</li>
</ul>
<p>可以让并发标记，混合收集提前开始来防止发生并发垃圾回收退化为Full GC的垃圾回收</p>
<h4 id=jdk-9-更高效的回收>JDK 9 更高效的回收<a hidden class=anchor aria-hidden=true href=#jdk-9-更高效的回收>#</a></h4>
<ul>
<li>250+增强</li>
<li>180+bug修复</li>
<li><a href=https://docs.oracle.com/en/java/javase/12/gctuning>HotSpot Virtual Machine Garbage Collection Tuning Guide</a></li>
<li>G1越来越好了！</li>
</ul>
<h3 id=remark-辨析>Remark 辨析<a hidden class=anchor aria-hidden=true href=#remark-辨析>#</a></h3>
<iframe src="//player.bilibili.com/player.html?aid=70549061&cid=122227716&page=78" scrolling=no border=0 frameborder=no framespacing=0 allowfullscreen width=640 height=360></iframe>
<p><a href="https://www.bilibili.com/video/av70549061?p=78">重标记辨析,写屏障技术视频详解</a></p>
<ul>
<li>重标记</li>
<li>pre-write barrier + satb_mark_queue</li>
<li>remark阶段配合satb_mark_queue队列来进行判断。</li>
</ul>
<p>下图中：</p>
<ul>
<li>黑色代表已处理完的对象</li>
<li>褐色代表正在处理的对象</li>
<li>箭头代表有强引用的对象</li>
<li>白色代表可回收的垃圾</li>
</ul>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/30.png width=30%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px"></div>
</center>
<p>由于是并发标记，所以在发现一个对象没有被强引用后，该对象被标记为可回收，但是标记的过程是和线程并发的，所以在这过程中可能有别的线程改变了该对象的引用。</p>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/31.png width=30%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px"></div>
</center>
<p>如果再回收此对象，则会发生重大的错误，于是在并发标记后会使用重新标记来解决此类问题。</p>
<center>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/28.png width=50%>
<p>
<img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://raw.githubusercontent.com/liugangjian/blogImag/master/JVM2/29.png width=50%>
<p>
<div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px"></div>
</center>
<p>在对象的引用发生改变时，JVM会给它加入一个写屏障，写屏障的指令将C加入一个队列当中，并将其变为灰色，表示还没处理完，当并发标记结束后，重新标记的线程就会从队列中把对象取出来再进行进一步的处理。</p>
<p>结果发现C有强引用，则将其变为黑色，则不会将C对象当成垃圾回收掉。</p>
<h3 id=full-gc-辨析>Full GC 辨析<a hidden class=anchor aria-hidden=true href=#full-gc-辨析>#</a></h3>
<h4 id=serialgc>SerialGC<a hidden class=anchor aria-hidden=true href=#serialgc>#</a></h4>
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足发生的垃圾收集 - full gc</li>
</ul>
<h4 id=parallelgc>ParallelGC<a hidden class=anchor aria-hidden=true href=#parallelgc>#</a></h4>
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足发生的垃圾收集 - full gc</li>
</ul>
<h4 id=cms>CMS<a hidden class=anchor aria-hidden=true href=#cms>#</a></h4>
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足</li>
</ul>
<h4 id=g1>G1<a hidden class=anchor aria-hidden=true href=#g1>#</a></h4>
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足</li>
</ul>
<p>CMS和G1由于是并发标记和收集的阶段，如果回收的速度大于垃圾产生的速度，这时候还谈不上发生Full GC. 只有当垃圾的产生速度大于回速度的时候，会退化为串行的垃圾收集器，触发Full GC，导致STW，使得响应时间变长。</p>
<p>可以通过打印GC日志观察是否又FUll GC字样来判断是否发生了Full GC.</p>
<h3 id=垃圾回收器相关参数>垃圾回收器相关参数<a hidden class=anchor aria-hidden=true href=#垃圾回收器相关参数>#</a></h3>
<h4 id=串行>串行<a hidden class=anchor aria-hidden=true href=#串行>#</a></h4>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#f92672>-</span>XX<span style=color:#f92672>:+</span>UseSerialGC <span style=color:#f92672>=</span> Serial <span style=color:#f92672>+</span> SerialOld
</code></pre></div><h4 id=吞吐量优先>吞吐量优先<a hidden class=anchor aria-hidden=true href=#吞吐量优先>#</a></h4>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#f92672>-</span>XX<span style=color:#f92672>:+</span>UseParallelGC <span style=color:#f92672>~</span> <span style=color:#f92672>-</span>XX<span style=color:#f92672>:+</span>UseParallelOldGC
<span style=color:#f92672>-</span>XX<span style=color:#f92672>:</span>GCTimeRatio<span style=color:#f92672>=</span>ratio
<span style=color:#f92672>-</span>XX<span style=color:#f92672>:</span>MaxGCPauseMillis<span style=color:#f92672>=</span>ms
<span style=color:#f92672>-</span>XX<span style=color:#f92672>:</span>ParallelGCThreads<span style=color:#f92672>=</span>n
</code></pre></div><h4 id=响应时间优先>响应时间优先<a hidden class=anchor aria-hidden=true href=#响应时间优先>#</a></h4>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#f92672>-</span>XX<span style=color:#f92672>:+</span>UseConcMarkSweepGC <span style=color:#f92672>~</span> <span style=color:#f92672>-</span>XX<span style=color:#f92672>:+</span>UseParNewGC <span style=color:#f92672>~</span> SerialOld
<span style=color:#f92672>-</span>XX<span style=color:#f92672>:</span>ParallelGCThreads<span style=color:#f92672>=</span>n <span style=color:#f92672>~</span> <span style=color:#f92672>-</span>XX<span style=color:#f92672>:</span>ConcGCThreads<span style=color:#f92672>=</span>threads
<span style=color:#f92672>-</span>XX<span style=color:#f92672>:</span>CMSInitiatingOccupancyFraction<span style=color:#f92672>=</span>percent
<span style=color:#f92672>-</span>XX<span style=color:#f92672>:+</span>CMSScavengeBeforeRemark
</code></pre></div><h2 id=gc-调优>GC 调优<a hidden class=anchor aria-hidden=true href=#gc-调优>#</a></h2>
<ul>
<li>掌握 GC 相关的 VM 参数，会基本的空间调整</li>
<li>掌握相关工具</li>
<li>明白一点：调优跟应用、环境有关，没有放之四海而皆准的法则</li>
</ul>
<h3 id=调优领域>调优领域<a hidden class=anchor aria-hidden=true href=#调优领域>#</a></h3>
<ul>
<li>内存(GC)</li>
<li>锁竞争</li>
<li>cpu 占用</li>
<li>io</li>
</ul>
<h3 id=调优目标>调优目标<a hidden class=anchor aria-hidden=true href=#调优目标>#</a></h3>
<ul>
<li>【低延迟】还是【高吞吐量】？【网站开发】还是【科学研究】？选择合适的回收器</li>
<li>CMS，G1，ZGC</li>
<li>ParallelGC</li>
<li>Zing 零挺对，几乎没有STW时间</li>
</ul>
<h3 id=最快的-gc-是不发生-gc>最快的 GC 是不发生 GC<a hidden class=anchor aria-hidden=true href=#最快的-gc-是不发生-gc>#</a></h3>
<ul>
<li>查看 FullGC 前后的内存占用，考虑下面几个问题
<ul>
<li>数据是不是太多？
<ul>
<li>resultSet = statement.executeQuery(&ldquo;select * from 大表 limit n&rdquo;)</li>
</ul>
</li>
<li>数据表示是否太臃肿？
<ul>
<li>对象图</li>
<li>对象大小 16 Integer 24 int 4</li>
</ul>
</li>
<li>是否存在内存泄漏？
<ul>
<li>static Map map =</li>
<li>软</li>
<li>弱</li>
<li>第三方缓存实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id=新生代调优>新生代调优<a hidden class=anchor aria-hidden=true href=#新生代调优>#</a></h3>
<ul>
<li>新生代的特点
<ul>
<li>所有的 new 操作的内存分配非常廉价
<ul>
<li>TLAB thread-local allocation buffer</li>
</ul>
</li>
</ul>
</li>
<li>死亡对象的回收代价是零</li>
<li>大部分对象用过即死</li>
<li>Minor GC 的时间远远低于 Full GC</li>
<li>新生代越大越好吗？
<ul>
<li>-Xmn Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery). GC is performed in this region more often than in other regions. If the size for the young generation is too small, then a lot of minor garbage collections are performed. If the size is too large, then only full garbage collections are performed, which can take a long time to complete. Oracle recommends that you keep the size for the young generation greater than 25% and less than 50% of the overall heap size.</li>
</ul>
</li>
<li>新生代能容纳所有【并发量 * (请求-响应)】的数据</li>
<li>幸存区大到能保留【当前活跃对象+需要晋升对象】</li>
<li>晋升阈值配置得当，让长时间存活对象尽快晋升</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#f92672>-</span>XX<span style=color:#f92672>:</span>MaxTenuringThreshold<span style=color:#f92672>=</span>threshold
<span style=color:#f92672>-</span>XX<span style=color:#f92672>:+</span>PrintTenuringDistribution

Desired survivor size 48286924 bytes<span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> threshold <span style=color:#a6e22e>10</span> <span style=color:#f92672>(</span>max 10<span style=color:#f92672>)</span>
<span style=color:#f92672>-</span> age 1<span style=color:#f92672>:</span> 28992024 bytes<span style=color:#f92672>,</span> 28992024 total
<span style=color:#f92672>-</span> age 2<span style=color:#f92672>:</span> 1366864 bytes<span style=color:#f92672>,</span> 30358888 total
<span style=color:#f92672>-</span> age 3<span style=color:#f92672>:</span> 1425912 bytes<span style=color:#f92672>,</span> 31784800 total
<span style=color:#f92672>...</span>
</code></pre></div><h3 id=老年代调优>老年代调优<a hidden class=anchor aria-hidden=true href=#老年代调优>#</a></h3>
<p>以 CMS 为例</p>
<ul>
<li>CMS 的老年代内存越大越好</li>
<li>先尝试不做调优，如果没有 Full GC 那么已经&mldr;，否则先尝试调优新生代</li>
<li>观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1/4 ~ 1/3</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#f92672>-</span>XX<span style=color:#f92672>:</span>CMSInitiatingOccupancyFraction<span style=color:#f92672>=</span>percent<span style=color:#75715e>//发生老年代垃圾回收的阈值
</span></code></pre></div><h3 id=案例>案例<a hidden class=anchor aria-hidden=true href=#案例>#</a></h3>
<ul>
<li>案例1 Full GC 和 Minor GC频繁
<ul>
<li>可能是由于新生代的内存太小，导致在新对象创建时，Survivor区空间不够而需要下调晋升代数，导致很多对象提前放入老年代中从而恶性循环，因此可以尝试调大新生代的空间。</li>
</ul>
</li>
<li>案例2 请求高峰期发生 Full GC，单次暂停时间特别长 （CMS）
<ul>
<li>查看GC日志，看看是在哪个阶段耗时长，由于初始标记和并发标记比较快，重新标记时间比较长，重新标记需要扫描整个新生代，老年代，因此可以在重新标记之前，对新生代发生一次垃圾回收。</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>	<span style=color:#f92672>-</span>XX<span style=color:#f92672>:+</span>CMSScavengeBeforeRemark
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback></code></pre></div></li>
<li>案例3 老年代充裕情况下，发生 Full GC （CMS jdk1.7）
<ul>
<li>1.7是由于永久代的空间不足发生Full GC 在1.8以后可能可能是由于元空间的不足引发的Full GC.</li>
</ul>
</li>
</ul>
<section class=footnotes role=doc-endnotes>
<hr>
<ol>
<li id=fn:1 role=doc-endnote>
<p>The above quote is excerpted from Rob Pike&rsquo;s <a href="https://www.youtube.com/watch?v=PAAkCSZUG1c">talk</a> during Gopherfest, November 18, 2015.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
</ol>
</section>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://liugangjian.github.io/tags/first/>first</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://liugangjian.github.io/posts/usage-for-java-custom-annotations/>
<span class=title>« Prev Page</span>
<br>
<span>Usage for Java annotations</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://liugangjian.github.io/>Gangjian Liu</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>